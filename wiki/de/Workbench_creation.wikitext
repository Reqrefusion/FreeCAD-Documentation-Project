<languages/>
{{VeryImportantMessage|Diese Seite beschreibt eine bewährte Methode zum Erstellen von Workbenches, aber vor einigen Jahren gab es einen Vorschlag, wie die Struktur der Python-basierten externen Workbenches verbessert werden könnte. Es scheint eine gewisse Übereinstimmung darüber zu bestehen, dass diese Struktur einen neuen Standard setzen sollte, aber sie hat noch keinen Eingang in dieses Wiki gefunden (mit Ausnahme von zwei Links im Abschnitt Verwandte Themen).
Ein weiterer Absatz wurde erstellt, um den neuen Standard zu beschreiben.  Siehe[[https://forum.freecad.org/viewtopic.php?t=101843 Diskussion]]}}

{{Docnav/de
|[[Localisation/de|Lokalisierung]]
|[[Extra_python_modules/de|Zusätzliche Python Module]]
}}

{{TOCright}}

<span id="Introduction"></span>
==Einleitung==

Diese Seite zeigt, wie man einen neuen Arbeitsbereich zur FreeCAD-Oberfläche hinzufügt. [[Workbenches/de|Arbeitbereiche]] sind Behälter für FreeCAD-Befehle. Sie können in Python, in C++ oder in einer Mischung aus beiden programmiert werden, was den Vorteil hat, die Geschwindigkeit von C++ mit der Flexibilität von Python zu verbinden. In jedem Fall wird der neue Arbeitsbereich durch einen Satz von zwei Python-Dateien gestartet. Dies können "interne" Arbeitsbereiche sein, die im FreeCAD-Paket enthalten sind oder "externe" Arbeitsbereiche, die mit dem [[Std_AddonMgr/de|Addon-Manager]] erhältlich sind oder sie werden manuell über das Herunterladen einiger Quellen (repositories) aus dem Netz installiert. Interne Arbeitsbereiche können in C++, Python oder einer Kombination der beiden programmiert sein, wogegen externe Arbeitsbereiche nur in Python programmiert sein dürfen.

<span id="The_workbench_structure"></span>
== Die Struktur der Arbeitsbereiche ==

Es wird ein Ordner mit mit einem beliebigen Namen benötigt, der im Mod-Verzeichnis des Benutzers platziert wird, mit einer {{incode|Init.py}}-Datei und wahlweise einer {{incode|InitGui.py}}-Datei. Die Init-Datei wird immer ausgeführt, wenn FreeCAD startet und die {{incode|InitGui.py}}-Datei wird unmittelbar danach, aber nur, wenn FreeCAD im GUI-Modus startet. Das ist alles, was FreeCAD braucht, um deinen Arbeitsbereich beim Start zu finden und ihn in seine Oberfläche aufzunehmen.

Das Mod-Verzeichnis des Benutzers ist ein Unterverzeichnis des Anwendungsdaten-Verzeichnisses des Benutzers (letzteres findet man durch Eingabe von {{incode|App.getUserAppDataDir()}} in der [[Python_Console/de|Python-Konsole]]):
* Unter Linux ist es üblicherweise {{FileName|/home/<username>/.local/share/FreeCAD/Mod/}} ({{VersionPlus/de|0.20}}) oder {{FileName|/home/<username>/.FreeCAD/Mod/}} ({{VersionMinus/de|0.19}}).
* Unter Windows ist es {{FileName|%APPDATA%\FreeCAD\Mod\}}, das üblicherweise {{FileName|C:\Users\<username>\Appdata\Roaming\FreeCAD\Mod\}} ist.
* Unter macOS ist es üblicherweise {{FileName|/Users/<username>/Library/Application Support/FreeCAD/Mod/}}.

Das Mod-Verzeichnis sollte so aussehen:

{{Code|code=
/Mod/
 +-- MyWorkbench/
     +-- Init.py
     +-- InitGui.py
}}

Innerhalb dieser Dateien kannst du tun, was immer du willst. Normalerweise werden sie so verwendet:

* In der Datei Init.py werden einfach ein paar Dinge hinzugefügt, die auch dann verwendet werden, wenn FreeCAD im Konsolenmodus arbeitet, z.B. die Funktionen für das Importieren und Exportieren von Dateien.

* In der Datei InitGui.py wird normalerweise ein Arbeitsbereich definiert, der einen Namen, ein Symbol und eine Reihe von FreeCAD-Befehlen enthält (siehe unten). Diese Python-Datei definiert auch Funktionen, die ausgeführt werden, wenn FreeCAD geladen wird (man versucht dort, so wenig wie möglich auszuführen, um den Start nicht zu verlangsamen), eine weitere, die ausgeführt wird, wenn der Arbeitsbereich aktiviert wird (in der die meiste Arbeit erledigt wird), und eine dritte, wenn der Arbeitsbereich deaktiviert wird (damit Dinge entfernen werden können, wenn nötig).

Die hier beschriebene Struktur und der Dateiinhalt eines Arbeitsbereich sind der klassische Weg beim Anlegen eines Arbeitsbereichs. Man kann eine leichte Abwandlung in der Dateistruktur benutzen, wenn ein neuer Python-Arbeitsbereich erstellt werden soll; dieser alternative Weg kann am besten als "namespaced workbench" (Arbeitsbereich mit eigenem Namensraum) bezeichnet werden, wodurch die Möglichkeit eröffnet wird, pip zur Installation des neuen Arbeitsbereichs zu verwenden. Beide Strukturen funktionieren, und es ist eher die Frage, was man selbst bevorzugt, wenn man einen Arbeitsbereich erstellt. Das Aussehen und die Struktur von hier gezeigten Arbeitsbereichen sind im globalen Namensraum von FreeCAD enthalten, während sich das alternative Aussehen und die Struktur des Arbeitsbereichs in einem dedizierten Namensraum befindet. Siehe [[#New_Standard_External_Workbench|Neuer Standard-Externer-Arbeitsbereich]] weiter unten.

<span id="C++_workbench_structure"></span>
===Struktur eines C++-Arbeitsbereiches===

Wenn du deinen Arbeitsbereich in Python programmieren willst, brauchst du keine besondere Vorsicht walten zu lassen und kannst einfach deine anderen Python-Dateien zusammen mit deinen Init.py- und InitGui.py-Dateien unterbringen. Wenn du jedoch mit C++ arbeitest, solltest du größere Sorgfalt walten lassen und eine grundlegende Regel von FreeCAD beachten: die Trennung deines Arbeitsbereichs zwischen einem Anwendungsteil (der ohne jedes GUI-Element im Konsolenmodus laufen kann) und einem GUI-Teil, der nur geladen wird, wenn FreeCAD mit seiner vollständigen GUI-Umgebung läuft. Wenn du also einen C++-Arbeitsbereich erstellst, wirst du höchstwahrscheinlich zwei Module erstellen, eine Anwendung und eine GUI. Diese beiden Module müssen natürlich von Python aus aufrufbar sein. Jedes FreeCAD-Modul (Anwendung oder GUI) besteht mindestens aus einer Modul-Init-Datei. Dies ist eine typische AppMyModuleGui.cpp-Datei:

{{Code|code=
extern "C" {
    void MyModuleGuiExport initMyModuleGui()  
    {
         if (!Gui::Application::Instance) {
            PyErr_SetString(PyExc_ImportError, "Cannot load Gui module in console application.");
            return;
        }
        try {
            // import other modules this one depends on
            Base::Interpreter().runString("import PartGui");
            // run some python code in the console
            Base::Interpreter().runString("print('welcome to my module!')");
        }
        catch(const Base::Exception& e) {
            PyErr_SetString(PyExc_ImportError, e.what());
            return;
        }
        (void) Py_InitModule("MyModuleGui", MyModuleGui_Import_methods);   /* mod name, table ptr */
        Base::Console().Log("Loading GUI of MyModule... done\n");
    
        // initializes the FreeCAD commands (in another cpp file)
        CreateMyModuleCommands();
    
        // initializes workbench and object definitions
        MyModuleGui::Workbench::init();
        MyModuleGui::ViewProviderSomeCustomObject::init();
    
         // add resources and reloads the translators
        loadMyModuleResource();
    }
}
}}

<span id="The_Init.py_file"></span>
===Die Datei Init.py===

{{code|code=
"""FreeCAD init script of XXX module"""

# ***************************************************************************
# *   Copyright (c) 2015 John Doe john@doe.com                              *   
# *                                                                         *
# *   This file is part of the FreeCAD CAx development system.              *
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU Lesser General Public License (LGPL)    *
# *   as published by the Free Software Foundation; either version 2 of     *
# *   the License, or (at your option) any later version.                   *
# *   for detail see the LICENSE text file.                                 *
# *                                                                         *
# *   FreeCAD is distributed in the hope that it will be useful,            *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU Lesser General Public License for more details.                   *
# *                                                                         *
# *   You should have received a copy of the GNU Library General Public     *
# *   License along with FreeCAD; if not, write to the Free Software        *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
# *   USA                                                                   *
# *                                                                         *
# ***************************************************************************/

FreeCAD.addImportType("My own format (*.own)", "importOwn")
FreeCAD.addExportType("My own format (*.own)", "exportOwn")
print("I am executing some stuff here when FreeCAD starts!")
}}

Du kannst jede beliebige Lizenz für deinen Arbeitsbereich wählen, aber sei dir bewusst, dass, wenn du deinen Arbeitsbereich irgendwann in den FreeCAD-Quellcode integrierst und mit diesem verteilt sehen möchtest, diese wie im obigen Beispiel unter LGPL2+ stehen muss. Siehe [[License/de|Lizenz]].

Die Funktionen {{incode|FreeCAD.addImportType()}} und {{incode|addEXportType()}} ermöglichen es dir, den Namen und die Erweiterung eines Dateityps sowie ein für seinen Import verantwortliches Python-Modul anzugeben. Im obigen Beispiel wird ein Modul {{incode|importOwn.py}} {{incode|.own}}-Dateien verarbeiten. 
Siehe [[Code_snippets/de|Code-Schnipsel]] für weitere Beispiele.

<span id="Python_workbenches"></span>
===Python-Arbeitsbereiche===

Dies ist die Datei InitGui.py:

{{Code|code=
class MyWorkbench (Workbench):

    MenuText = "My Workbench"
    ToolTip = "A description of my workbench"
    Icon = """paste here the contents of a 16x16 xpm icon"""

    def Initialize(self):
        """This function is executed when the workbench is first activated.
        It is executed once in a FreeCAD session followed by the Activated function.
        """
        import MyModuleA, MyModuleB # import here all the needed files that create your FreeCAD commands
        self.list = ["MyCommand1", "MyCommand2"] # a list of command names created in the line above
        self.appendToolbar("My Commands", self.list) # creates a new toolbar with your commands
        self.appendMenu("My New Menu", self.list) # creates a new menu
        self.appendMenu(["An existing Menu", "My submenu"], self.list) # appends a submenu to an existing menu

    def Activated(self):
        """This function is executed whenever the workbench is activated"""
        return

    def Deactivated(self):
        """This function is executed whenever the workbench is deactivated"""
        return

    def ContextMenu(self, recipient):
        """This function is executed whenever the user right-clicks on screen"""
        # "recipient" will be either "view" or "tree"
        self.appendContextMenu("My commands", self.list) # add commands to the context menu

    def GetClassName(self): 
        # This function is mandatory if this is a full Python workbench
        # This is not a template, the returned string should be exactly "Gui::PythonWorkbench"
        return "Gui::PythonWorkbench"
       
Gui.addWorkbench(MyWorkbench())
}}

Ansonsten kannst du alles tun, was du willst: Du kannst deinen gesamten Code des Arbeitsbereichs in die InitGui.py speichern, wenn du möchtest, aber es ist normalerweise bequemer, die verschiedenen Funktionen deines Arbeitsbereiches in separate Dateien abzulegen. Dadurch sind diese Dateien kleiner und einfacher zu lesen. Dann importierst du diese Dateien in deine InitGui.py-Datei. Du kannst diese Dateien anordnen wie du willst; ein gutes Beispiel ist eine für jeden FreeCAD-Befehl, den du hinzufügst.

<span id="Preferences"></span>
====Einstellungen====

Du kannst eine Einstellungsseite für deinen Python-Arbeitsbereich hinzufügen.  
Die Einstellungsseiten suchen nach einem Einstellungssymbol mit einem bestimmten Namen im Qt-Ressourcensystem. Wenn sich dein Symbol nicht im Ressourcensystem befindet oder nicht den korrekten Namen hat, wird dein Symbol nicht auf der Einstellungsseite erscheinen.

Hinzufügen deines Arbeitsbereichssymbols:
* das Einstellungssymbol muss "preferences-" genannt werden + "modulename" + ".svg" (alles Kleinbuchstaben)
* erstelle eine qrc-Datei, die alle Symbolnamen enthält
* Führe im *.py-Hauptverzeichnis pyside-rcc -o myResources.py myqrc.qrc aus
* In InitGui.py, füge import myResource(.py) hinzu
* aktualisiere dein Repositorium (git) mit myResources.py und myqrc.qrc

Du musst du die Schritte erneut ausführen wenn du Symbole hinzufügst/änderst, 

@kbwbe hat ein nettes Skript zum Kompilieren von Ressourcen für den Arbeitsbereich A2Plus erstellt. Siehe unten. 

Hinzufügen deiner Einstellungsseite(n):
* Du musst das Qt Designer-Zusatzmodul kompilieren, das dir das Hinzufügen von Präferenzeinstellungen mit [[Compile on Linux/de#Qt_designer_plugin|Qt Designer]] ermöglicht
* Erstelle ein leeres Widget im Qt Designer (keine Schaltflächen oder ähnliches)
* Gestalte deine Präferenzseite, jede Einstellung, die gespeichert werden muss (Präferenzen), muss eines der Gui::Pref*-Widgets sein, die durch das Zusatzmodul hinzugefügt wurden)
* Stelle sicher, dass du in einem dieser Felder den PrefName (den Namen deines Präferenzwertes) und PrefPath (z.B.: Mod/MyWorkbenchName), der deine Werte unter BaseApp/Preferences/Mod/MyWorkbenchName speichern wird
* Speichere die ui-Datei in deinem Arbeitsbereich, stelle sicher, dass sie von cmake verarbeitet wird
* In deinem Arbeitsbereich, z.B. innerhalb der Datei InitGui, innerhalb der Initialisierungsmethode (aber jeder andere Ort funktioniert auch), füge hinzu: FreeCADGui.addPreferencePage("/path/to/myUiFile.ui","MyGroup"), "MyGroup" als eine der Präferenzgruppen auf der linken Seite. FreeCAD sucht automatisch nach einer Datei "preferences-mygroup.svg" an den bekannten Speicherorten (die du mit FreeCADGui.addIconPath() erweitern kannst)
* Stelle sicher, dass die Methode addPreferencePage() nur einmal aufgerufen wird, andernfalls wird deine Vorzugsseite mehrmals hinzugefügt

<span id="Distribution"></span>
====Veröffentlichen====

Um einen eigenen Python-Arbeitsbereich zu veröffentlichen (und zu verbreiten), können die Dateien einfach an einem bestimmten Ort bereitgestellt und die Anwender angeleitet werden, wie die Dateien herunterzuladen und manuell in ihrem Mod-Verzeichnis abzulegen sind oder sie können in einem Online-git-Datenspeicher (GitHub, GitLab, Framagit und Debian Salsa werden zurzeit unterstützt) bereitgestellt und für die Installation mit dem [[Std_AddonMgr/de|Addon-Manager]] konfiguriert werden. Anweisungen zum Einbinden in FreeCADs offizieller Addon-Liste befinden sich unter [https://github.com/FreeCAD/FreeCAD-addons/blob/master/README.md FreeCAD Addons GitHub repository] (engl.). Um den Addon-Manager zu verwenden, sollte eine Metadaten-Datei [[Package_Metadata/de|package.xml]] enthalten sein, die dem Addon-Manager zeigt, wo das Symbol des Arbeitsbereiches zu finden ist und die die Anzeige von Beschreibung, Versionsnummer und anderem ermöglicht. Sie kann auch verwendet werden, um andere Arbeitsbereiche oder Python-Pakete anzugeben, von denen der eigene Arbeitsbereich abhängt, die ihn blockieren oder die er ersetzen soll.

Für eine Kurzanleitung wie man eine einfache package.xml-Datei erstellt und einen Arbeitsbereich zum [[Std_AddonMgr/de|Addon-Manager]] hinzufügt, siehe: [[Add_Workbench_to_Addon_Manager/de|Arbeitsbereich zum Addon-Manager hinzufügen]].

Wahlweise kann eine separate Metadaten-Datei enthalten sein, die die eigenen Python-Abhängigkeiten beschreibt. Dies kann eine Datei metadata.txt sein, die die externen Abhängigkeiten des eigenen Arbeitsbereichs beschreibt (von entweder anderen Addons, Arbeitsbereichen oder Python-Modulen) oder eine Datei [https://pip.pypa.io/en/latest/reference/requirements-file-format/ requirements.txt], die die Python-Abhängigkeiten beschreibt. Man beachte, dass wenn eine requirements.txt-Datei verwendet wird, nur die Namen der angegebenen Pakete zum Auflösen der Abhängigkeiten eingesetzt werden: pip-Befehlsoptionen, Include-Optionen und Versionsinformationen werden vom Addon-Manager nicht unterstützt. Anwender können die requirements-Datei manuell mit pip ausführen, wenn diese Elemente erforderlich sind.

Das Format der Datei metadata.txt ist einfacher Text und enthält drei optionalen Zeilen:

{{Code|code=
workbenches=
pylibs=
optionalpylibs=
}}

Jede Zeile sollte aus einer durch Komma getrennten Liste von Elementen bestehen, von der der eigene Arbeitsbereich abhängt. Arbeitsbereiche können entweder ein interner FreeCAD-Arbeitsbereich, z.B. "FEM", oder ein externes Addon, z.B. "Curves" sein. Die benötigten oder wählbaren Python-Bibliotheken sollten mit ihren regelkonformen Python-Namen benannt werden, wie sie auch mit {{incode|pip install}} verwendet werden. Zum Beispiel:

{{Code|code=
workbenches=FEM,Curves
pylibs=ezdxf
optionalpylibs=metadata,git
}}

Du kannst auch ein Skript einfügen, das gestartet wird, wenn dein Paket deinstalliert wird. Das wäre die Datei "uninstall.py", die ganz oben in deinem Addon zu finden wäre. Es wird ausgeführt, wenn ein Benutzer dein Addon mit dem Addon-Manager deinstalliert.
Es wird verwendet, um alles, was das Addon auf dem Benutzersystem gemacht hat und nicht dort bleiben soll, zu entfernen, wenn das Addon deinstalliert ist, z.B. Cachedateien entfernen etc.

Um zu gewährleisten, dass dein Addon vom Addon-Manager richtig gelesen werden kann, kann der "developer mode" aktiviert werden, in dem der Addon-Manager alle verfügbaren Addons prüft und gewährleistet, dass deren Metadaten die erforderlichen Elemente enthält. Diesen Modus aktiviert man durch Auswahl von {{MenuCommand|Bearbeiten → Einstellungen... → Addon-Manager → Addon-Manager-Optionen → Addon-Entwickler-Modus}}, siehe [[Preferences_Editor/de#Addon-Manager|Voreinstellungseditor]].

<span id="C++_workbenches"></span>
===C++ Arbeitsbereiche===

Wenn du deinen Arbeitsbereich in C++ programmierst, wirst du wahrscheinlich die
Arbeitsbereichsdefinition selbst auch in C++ programmieren (obwohl es nicht notwendig ist: du könntest auch nur die Werkzeuge in C++ programmieren und die Arbeitsbereichsdefinition in Python belassen). In diesem Fall, wird die Datei InitGui.py sehr einfach: Sie könnte nur eine Zeile enthalten:

{{Code|code=import MyModuleGui}}

wobei MyModule dein vollständiger C++ Arbeitsbereich ist, der die Befehle und Arbeitsbereichsdefinition einschließt.

Die Programmierung von C++ Arbeitsbereichen funktioniert auf ziemlich ähnliche Weise. Dies ist eine typische Workbench.cpp-Datei, die du in den Gui-Teil deines Moduls aufnehmen kannst:

{{Code|code=
namespace MyModuleGui {
    class MyModuleGuiExport Workbench : public Gui::StdWorkbench
    {
        TYPESYSTEM_HEADER();

    public:
        Workbench();
        virtual ~Workbench();

        virtual void activated();
        virtual void deactivated();

    protected:
        Gui::ToolBarItem* setupToolBars() const;
        Gui::MenuItem*    setupMenuBar() const;
    };
}
}}

<span id="Preferences"></span>
====Einstellungen====

Du kannst auch eine Voreinstellungsseite für C++ Arbeitsbereiche hinzufügen. Die Schritte sind ähnlich wie die für Python.

<span id="Distribution"></span>
====Veröffentlichen====

Es gibt zwei Optionen zum Veröffentlichen (und verbreiten) eines  C++ -Arbeitsbereiches; es können eigene vorkompilierte Versionen für die unterschiedlichen Betriebssysteme bereitgestellt werden oder man fragt das Einbinden in den FreeCADs Quellcode an. Wie oben erwähnt, erfordert dies eine LGPL2+ -Lizenz und man muss den Arbeitsbereich der Gemeinschaft im [https://forum.freecad.org FreeCAD-Forum] zur Bewertung vorstellen.

<span id="FreeCAD_commands"></span>
==FreeCAD-Befehle==

FreeCAD-Befehle sind die Grundbausteine der FreeCAD-Oberfläche. Sie können als Schaltflächen in Symbolleisten und als Einträge in Menüs erscheinen. Es handelt sich dabei immer um denselben Befehl. Ein Befehl ist einfach eine Python-Klasse, die eine Reihe von vordefinierten Attributen und Funktionen enthält, wie der Befehlsname, das Symbol und der Code, der ausgeführt wird, wenn der Befehl aktiviert wird.

<span id="Python_command_definition"></span>
=== Python Befehlsdefinition ===

{{Code|code=
class My_Command_Class():
    """My new command"""

    def GetResources(self):
        return {"Pixmap"  : "My_Command_Icon", # the name of a svg file available in the resources
                "Accel"   : "Shift+S", # a default shortcut (optional)
                "MenuText": "My New Command",
                "ToolTip" : "What my new command does"}

    def Activated(self):
        """Do something here"""
        return

    def IsActive(self):
        """Here you can define if the command must be active or not (greyed) if certain conditions
        are met or not. This function is optional."""
        return True

FreeCADGui.addCommand("My_Command", My_Command_Class())
}}

<span id="C++_command_definition"></span>
=== C++ Befehlsdefinition ===

In ähnlicher Weise können Befehle in C++ programmiert werden, normalerweise in  einer Commands.cpp-Datei in deinem GUI-Modul. Dies ist eine typische Commands.cpp-Datei:

{{Code|code=DEF_STD_CMD_A(CmdMyCommand);

CmdMyCommand::CmdMyCommand()
  :Command("My_Command")
{
  sAppModule    = "MyModule";
  sGroup        = QT_TR_NOOP("MyModule");
  sMenuText     = QT_TR_NOOP("Runs my command...");
  sToolTipText  = QT_TR_NOOP("Describes what my command does");
  sWhatsThis    = QT_TR_NOOP("Describes what my command does");
  sStatusTip    = QT_TR_NOOP("Describes what my command does");
  sPixmap       = "some_svg_icon_from_my_resource";
}

void CmdMyCommand::activated(int iMsg)
{
    openCommand("My Command");
    doCommand(Doc,"print('Hello, world!')");
    commitCommand();
    updateActive();
}

bool CmdMyCommand::isActive(void)
{
  if( getActiveGuiDocument() )
    return true;
  else
    return false;
}

void CreateMyModuleCommands(void)
{
    Gui::CommandManager &rcCmdMgr = Gui::Application::Instance->commandManager();
    rcCmdMgr.addCommand(new CmdMyCommand());
}
}}

<span id="&quot;Compiling&quot;_your_resource_file"></span>
=="Kompilieren" deiner Ressourcendatei==

compileA2pResources.py aus dem Arbeitsbereich A2Plus:

{{Code|code=#!/usr/bin/env python
# -*- coding: utf-8 -*-
#***************************************************************************
#*                                                                         *
#*   Copyright (c) 2019 kbwbe                                              *
#*                                                                         *
#*   Portions of code based on hamish's assembly 2                         *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU Lesser General Public License (LGPL)    *
#*   as published by the Free Software Foundation; either version 2 of     *
#*   the License, or (at your option) any later version.                   *
#*   for detail see the LICENSE text file.                                 *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU Library General Public License for more details.                  *
#*                                                                         *
#*   You should have received a copy of the GNU Library General Public     *
#*   License along with this program; if not, write to the Free Software   *
#*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
#*   USA                                                                   *
#*                                                                         *
#***************************************************************************

# This script compiles the A2plus icons for py2 and py3
# For Linux only
# Start this file in A2plus main directory
# Make sure pyside-rcc is installed

import os, glob

qrc_filename = 'temp.qrc'
if os.path.exists(qrc_filename):
    os.remove(qrc_filename)

qrc = '''<RCC>
\t<qresource prefix="/">'''
for fn in glob.glob('./icons/*.svg'):
    qrc = qrc + '\n\t\t<file>%s</file>' % fn
qrc = qrc + '''\n\t</qresource>
</RCC>'''

print(qrc)

f = open(qrc_filename,'w')
f.write(qrc)
f.close()

os.system(
    'pyside-rcc -o a2p_Resources2.py {}'.format(qrc_filename))
os.system(
    'pyside-rcc -py3 -o a2p_Resources3.py {}'.format(qrc_filename))

os.remove(qrc_filename)
}}

<span id="New_Standard_External_Workbench"></span>
== Neuer Standard-Externer-Arbeitsbereich ==

<div lang="en" dir="ltr" class="mw-content-ltr">
The structure and file content for a workbench described above is the classic way of creating a new workbench. One can use a slight variation in the structure of files when making a new Python workbench, that alternative way is best described as a '''namespaced workbench''', opening up the possibility to use pip to install the workbench. Both structures work, so it is more a question of preference when creating a new workbench. The style and structure for these workbenches reside in a dedicated namespace, instead of being available in the global namespace of FreeCAD.
</div>

 <div lang="en" dir="ltr" class="mw-content-ltr">
(Add an explanation of '''dedicated namespace''')
</div>

<span id="Structure"></span>
=== Struktur ===

<div lang="en" dir="ltr" class="mw-content-ltr">
This structure is also based on the /Mod directory (see [[#The_workbench_structure|the workbench structure]] above) but differs in the use of subdirectories:
</div>

{{Code|code=
/Mod/
 +-- MyWorkbench/
     +-- freecad/
         +-- MyWorkbench/
             +-- __init.py__
             +-- init_gui.py
             +-- resources/
                 +-- icons/
                 +-- translations/
}}

<span id="Starter_Kit"></span>
=== Starter-Kit ===

Ein Starter-Kit zum Erstellen der Struktur eines externen Python-Arbeitsbereichs ist auf GitHub verfügbar: [https://github.com/FreeCAD/freecad.workbench_starterkit FreeCAD Workbench Starter Kit]

<span id="Related"></span>
==Verwandtes==

* [[Translating_an_external_workbench/de|Übersetzen eines externen Arbeitsbereichs]]
* [https://forum.freecad.org/viewtopic.php?t=47460 Forum discussion: Namespaced Workbenches]
* [https://github.com/FreeCAD/freecad.workbench_starterkit freecad.workbench_starterkit]


{{Docnav/de
|[[Localisation/de|Lokalisierung]]
|[[Extra_python_modules/de|Zusätzliche Python Module]]
}}

{{Powerdocnavi{{#translation:}}}}
[[Category:Developer Documentation{{#translation:}}]]
[[Category:Python Code{{#translation:}}]]