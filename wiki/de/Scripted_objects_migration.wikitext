<languages/>

<span id="Introduction"></span>
== Einleitung ==

[[Scripted_objects/de|Geskriptete Objekte]] werden jedes Mal neu aufgebaut, wenn ein [[File_Format_FCStd/de|FCStd Dokument]] geöffnet wird. Zu diesem Zweck behält das Dokument eine Referenz auf das Modul und die Python Klasse, die zur Erstellung des Objekts verwendet wurden, zusammen mit seinen Eigenschaften.

{{Code|lang=xml|code=
<Document SchemaVersion="4" ProgramVersion="0.19R20959 (Git)" FileVersion="1">
    ...
    <Properties Count="15" TransientCount="3">
    ...
    </Properties>
    <Objects Count="1" Dependencies="1">
        <ObjectDeps Name="Custom" Count="0"/>
        <Object type="Part::FeaturePython" name="Custom" id="2715" Touched="1" />
    </Objects>
    <ObjectData Count="1">
        <Object name="Custom">
            <Properties Count="9" TransientCount="0">
                ...
                <Property name="Proxy" type="App::PropertyPythonObject" status="1">
                    <Python value="eyJUeXBlIjogIkN1c3RvbSJ9" encoded="yes" module="old_module" class="OldObject"/>
                </Property>
                ...
            </Properties>
        </Object>
    </ObjectData>
</Document>
}}

Konzentriere dich besonders auf diesen Teil:
{{Code|lang=xml|code=
                ...
                <Property name="Proxy" type="App::PropertyPythonObject" status="1">
                    <Python value="eyJUeXBlIjogIkN1c3RvbSJ9" encoded="yes" module="old_module" class="OldObject"/>
                </Property>
                ...
}}

Wenn der Wert von <code>module=</code> oder <code>class=</code> auf dem installierten System nicht gefunden wird, kann das Objekt nicht korrekt geladen werden. Das bedeutet, dass, sobald ein Objekt mit einer bestimmten Klasse erstellt wurde, das Modul nicht mehr verschoben oder umbenannt werden sollte, da zuvor gespeicherte Objekte sonst kaputt gehen.

Ein triftiger Grund für die Verschiebung oder Umbenennung des Moduls oder der Klasse ist jedoch die Verbesserung der Struktur und Wartbarkeit des ursprünglichen Codes, z.B. bei der Umstrukturierung einer ganzen Werkbank. In diesem Fall gibt es verschiedene Strategien, um alte Objekte auf die Verwendung einer neuen Klasse zu migrieren. Dies geschieht aus Gründen der Abwärtskompatibilität, wenn ein völliges Aufbrechen alter Dokumente vermieden werden muss.

<span id="Old_object_and_new_object"></span>
== Altes Objekt und neues Objekt ==

<span id="Old_object"></span>
=== Altes Objekt ===

Ein altes Objekt wird in einem Baustein definiert, der sich an der Wurzel der Arbeitsbereichs befindet.
{{Code|code=
# old_module.py
class OldObject:
    def __init__(self, obj):
        obj.addProperty("App::PropertyLength", "Length")
        obj.addProperty("App::PropertyArea", "Area")
        obj.Length = 15
        obj.Area = 300
        obj.Proxy = self
        self.Type = "Custom"

    def execute(self, obj):
        pass
}}

Mit dieser Klasse kann ein Objekt erstellt und unter {{FileName|mein_Dokument.FCstd}} gespeichert werden. Wenn dem neuen Objekt kein bestimmter [[viewprovider/de|Ansichtsanbieter]] zugewiesen ist, wird seine Proxy Klasse einfach auf einen anderen Wert als {{incode|None}} gesetzt, in diesem Fall auf {{incode|1}}.
{{Code|code=
import FreeCAD as App
import old_module

doc = App.newDocument()
doc.FileName = "my_document.FCStd"

obj = doc.addObject("Part::FeaturePython", "Custom")
old_module.OldObject(obj)

if App.GuiUp:
    obj.ViewObject.Proxy = 1

doc.recompute()
doc.save()
}}

[[Python_console/de|Python Konsole]] Sitzung, bei der die grundlegenden Eigenschaften weggelassen wurden.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.PropertiesList)
['Area', ..., ..., ..., 'Length', ..., ..., ..., ...]
>>> print(obj.Proxy)
<old_module.OldObject object at 0x7efc3c51c390>
}}

<span id="New_object"></span>
=== Neues Objekt ===

Nun betrachten wir, dass der Arbeitsbereich umstrukturiert wird, so dass sich die Klassen nicht nur im Stammverzeichnis, sondern stattdessen in einem {{FileName|objects}} Verzeichnis befinden. Komplexe Arbeitsbereiche, die viele verschiedene Arten von Objekten haben, sollten in Verzeichnissen strukturiert werden, die Objekte, [[Viewprovider/de|AnsichtBereitsteller]], [[Command/de|Gui Befehle]], [[task_panel/de|Aufgabenpaneel]] Schnittstellen usw. enthalten.
{{Code|code=
# objects/new_module.py
class NewObject:
    def __init__(self, obj):
        obj.addProperty("App::PropertyLength", "Length")
        obj.addProperty("App::PropertyArea", "GeneralArea")
        obj.addProperty("App::PropertyInteger", "Divisions")
        obj.Length = 30
        obj.GeneralArea = 600
        obj.Divisions = 4
        obj.Proxy = self
        self.Type = "Custom"

    def execute(self, obj):
        pass
}}

Diese neue Klasse wird sich auf den gleichen Objekttyp beziehen, aber sowohl der Modulname als auch der Klassenname wurden umbenannt. Darüber hinaus haben sich auch die Eigenschaften geändert; eine Eigenschaft wurde umbenannt, und eine völlig neue Eigenschaft wurde hinzugefügt.

Wenn wir ein neues Objekt mit diesem neuen Modul erstellen, haben wir die folgende Konsolensitzung.
{{Code|code=
>>> obj2 = App.ActiveDocument.Custom2
>>> print(obj2.PropertiesList)
['Divisions', ..., 'GeneralArea', ..., ..., 'Length', ..., ..., ..., ...]
>>> print(obj2.Proxy)
<objects.new_module.NewObject object at 0x7efc1cf68c50>
}}

<span id="Method_1._Migration_by_redirecting_the_class"></span>
== Methode 1. Migration durch Umleitung der Klasse ==

Wir werden das ältere Objekt migrieren, indem wir die alte Klasse umleiten. Die ursprüngliche Klasse wird gelöscht, und der Name der Klasse wird einfach umgeleitet, um auf die neue Klasse zu verweisen.

{{Code|code=
# old_module.py
import objects.new_module as new_module

OldObject = new_module.NewObject
}}

Jedes Dokument, das versucht, {{incode|old_module.OldObject}} zu laden, wird stattdessen zum Laden von {{incode|objects.new_module.NewObject}} umgeleitet.

Wenn wir das Dokument öffnen und die Eigenschaften des Objekts in der [[Python_console/de|Python Konsole]] überprüfen, werden wir sehen, dass die älteren Eigenschaften erhalten bleiben, das Objekt aber eine neue Proxy Klasse hat.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.PropertiesList)
['Area', ..., ..., ..., 'Length', ..., ..., ..., ...]
>>> print(obj.Proxy)
<objects.new_module.NewObject object at 0x7f099700b2b0>
}}

In diesem Fall sehen wir jedoch nicht die neuen Eigenschaften der neuen Klasse. Der Grund dafür ist einfach, dass das ältere Objekt diese Eigenschaften nicht hatte. Wenn {{incode|old_module.OldObject}} zu {{incode|objects.new_module.NewObject}} umgeleitet wurde, änderte sich nur die Proxy Klasse, aber die vorherigen Informationen wurden beibehalten.

Wenn das Dokument nun gespeichert und wieder geöffnet wird, sucht es automatisch nach {{incode|objects.new_module.NewObject}}, und es benötigt nicht mehr {{incode|old_module.OldObject}}. Die Datei {{FileName|old_module.py}} kann dauerhaft aus dem System entfernt werden, solange alle älteren Objekte in das neue Modul migriert worden sind. Wenn das alte Modul entfernt wird, aber ein Objekt nicht migriert wurde, zeigt die [[report_view/de|Berichtsansicht]] beim Öffnen eines Dokuments, das ein solches Objekt enthält, eine Meldung wie diese an.

{{Code|lang=bash|code=
<class 'ModuleNotFoundError'>: No module named 'old_module'
}}

Wenn es realistischerweise nicht möglich ist, alle älteren Objekte zu migrieren, z.B. weil das alte Modul viele Jahre lang in einem Arbeitsbereich verwendet wurde, muss {{FileName|old_module.py}} so lange beibehalten werden, wie es für notwendig erachtet wird, um den Benutzern die Möglichkeit zu geben, ihre Objekte zu migrieren.

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

* [[File:Edit_OK.svg|24px]] Dies ist die einfachste Methode, bei der lediglich eine alte Klasse in eine neue Klasse umgeleitet werden muss.
* [[File:Edit_OK.svg|24px]]  Alte Eigenschaften bleiben erhalten, solange die neue Klasse sie nicht außer Kraft setzt.
* [[File:Edit_OK.svg|24px]]  Dies ist gut, wenn die alte Klasse und die neue Klasse die gleichen Eigenschaften haben (die gleiche Art von Daten verarbeiten), aber nur ihr Modul- oder Klassenname unterschiedlich ist.

'''Nachteile'''

* [[File:Edit_Cancel.svg|24px]] Die neue Klasse behält die alten Eigenschaften des Objekts bei, was nicht immer erwünscht ist.
* [[File:Edit_Cancel.svg|24px]] Neue Eigenschaften oder umbenannte Eigenschaften werden nicht behandelt, so dass das Objekt zwar geladen wird, aber möglicherweise nicht das korrekte Verhalten der neuen Klasse zeigt.
* [[File:Edit_Cancel.svg|24px]] Das alte Modul muss möglicherweise auf unbestimmte Zeit aufbewahrt werden, um alle alten, in der Vergangenheit erstellten Objekte zu migrieren.

<span id="Method_2._Migration_when_restoring_the_document"></span>
== Methode 2. Migration beim Wiederherstellen des Dokuments ==

Wir werden das ältere Objekt migrieren, indem wir die alte Klasse modifizieren. Der Großteil der ursprünglichen Klasse wird gelöscht, und stattdessen wird die Methode {{incode|onDocumentRestored}} implementiert. Wenn diese Methode vorhanden ist, wird sie ausgeführt, wenn das Dokument versucht, ein Objekt wiederherzustellen, das die Klasse verwendet. Dies ist also die Gelegenheit, eine neue Klasse zuzuweisen, die Informationen zu manipulieren oder Nachrichten zu drucken.

In diesem Fall nehmen wir an, dass wir auch einen neuen [[viewprovider/de|AnsichtBereitsteller]] im Modul {{FileName|viewp/new_view.py}} definiert haben. Wenn wir diese Klasse nicht migrieren wollen, können wir nach der Prüfung {{incode|App.GuiUp}} alles weglassen.
{{Code|code=
# old_module.py
import FreeCAD as App
import objects.new_module as new_module
import viewp.new_view as new_view
_wrn = App.Console.PrintWarning

class OldObject:
    def onDocumentRestored(self, obj):
        new_module.NewObject(obj)
        _wrn("New proxy class used\n")

        if App.GuiUp:
            new_view.ViewProviderNew(obj.ViewObject)
            _wrn("New viewprovider class used\n")
}}

In einem komplexeren Beispiel wird zunächst geprüft, ob die Proxy Klasse dem gesuchten Typ entspricht, und erst dann mit der Migration fortgefahren, wenn es sich um den richtigen Typ handelt.
{{Code|code=
class OldObject:
    def onDocumentRestored(self, obj):
        if hasattr(obj, "Proxy") and obj.Proxy.Type == "Custom":
            _module = str(obj.Proxy.__class__)
            _module = _module.lstrip("<class '").rstrip("'>")

            if _module == "old_module.OldObject":
                self._migrate(obj)

    def _migrate(self, obj):
        _wrn("New proxy class used\n")
        new_module.NewObject(obj)

        if App.GuiUp:
            new_view.ViewProviderNew(obj.ViewObject)
            _wrn("New viewprovider class used\n")
}}

Wenn wir davon ausgehen, dass wir das alte Modul bereits auf diese Weise geändert haben, werden wir, wenn wir ein Dokument mit einem alten Objekt öffnen, die Meldungen sehen, in denen die Verwendung der neuen Klassen erwähnt wird.

Wenn wir das Objekt von der [[Python_console/de|Python Konsole]] aus inspizieren, werden wir sehen, dass die älteren Eigenschaften erhalten geblieben sind, und zusätzlich wurden zusammen mit der neuen Proxy Klasse neue Eigenschaften hinzugefügt.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.PropertiesList)
['Area', 'Divisions', ..., 'GeneralArea', ..., ..., 'Length', 'Length1', ..., ..., ..., ...]
>>> print(obj.Proxy)
<objects.new_module.NewObject object at 0x7fecb0ebd7b8>
}}

Die alten Eigenschaften waren {{incode|Area}} und {{incode|Length}}; die neuen Eigenschaften sind {{incode|Divisions}}, {{incode|GeneralArea}} und {{incode|Length}}. Das migrierte Objekt behält die beiden ursprünglichen Eigenschaften bei und erhält drei neue Eigenschaften. Da die neue {{incode|Length}} jedoch denselben Namen wie die ältere Eigenschaft hat, wird die neue Eigenschaft mit einer inkrementellen Nummer umbenannt. Vermutlich ist dies nicht das, was wir wollen. Wir können die Situation verbessern, indem wir dem Zusatz 2.1 unten folgen.

Da die Klassen den gleichen Objekttyp behandeln sollen, wünschen wir uns eine Migration, bei der sich {{incode|Area}} in {{incode|GeneralArea}} verwandelt und {{incode|Length}} einfach dem neuen {{incode|Length}} zugewiesen wird und es keine doppelten Eigenschaften gibt.

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

* [[File:Edit_OK.svg|24px]] Mit dieser Methode können wir überprüfen, ob die Klasse, die wir migrieren, die richtige Klasse ist, anstatt einfach zu einer neueren Klasse umzuleiten.
* [[File:Edit_OK.svg|24px]] Ähnlich wie bei Methode 1 bleiben alte Eigenschaften erhalten, solange die neue Klasse sie nicht überschreibt.
* [[File:Edit_OK.svg|24px]] Im Gegensatz zu Methode 1 werden neue Eigenschaften immer hinzugefügt, jedoch werden sie umbenannt, wenn sie denselben Namen haben.
* [[File:Edit_OK.svg|24px]] Die Migration erfolgt nicht sofort, wir können die Informationen weiterhin bearbeiten oder Meldungen ausdrucken, während das Objekt geladen wird.

'''Nachteile'''

* [[File:Edit_Cancel.svg|24px]] Es ist ausführlicher als Methode 1, da wir die Methode {{incode|onDocumentRestored}} implementieren müssen, um das Objekt zu migrieren.
* [[File:Edit_Cancel.svg|24px]] Es werden immer die neuen Eigenschaften hinzugefügt, sodass es zu doppelten Eigenschaften kommen kann, wenn die neuen Eigenschaften denselben Namen wie die alten Eigenschaften haben. Dies muss manuell behoben werden.

<span id="Method_3._Migration_when_restoring_the_document,_manually_handling_the_properties"></span>
== Methode 3. Migration beim Wiederherstellen des Dokuments, manuelle Handhabung der Eigenschaften ==

Dies ist eine Erweiterung von Methode 2. In der Methode {{incode|onDocumentRestored}} müssen wir die Werte der gewünschten Eigenschaften speichern und können dann diese ursprünglichen Eigenschaften entfernen. Dies geschieht, damit bei Verwendung der neuen Klasse die neuen Eigenschaften zugewiesen werden, ohne dass es zu Namenskonflikten mit den älteren Eigenschaften kommt.

Wie in Methode 2 können wir auch hier einen Code hinzufügen, der überprüft, ob die Proxy-Klasse die richtige ist. In diesem Beispiel gehen wir erneut davon aus, dass wir einen benutzerdefinierten [[Viewprovider/de|Viewprovider]] mit mindestens einer benutzerdefinierten Eigenschaft verwenden.
{{Code|code=
# old_module.py
import FreeCAD as App
import objects.new_module as new_module
import viewp.new_view as new_view
_wrn = App.Console.PrintWarning

class OldObject:
    def onDocumentRestored(self, obj):
        old = dict()
        old["Area"] = obj.Area
        old["Length"] = obj.Length
        obj.removeProperty("Area")
        obj.removeProperty("Length")

        new_module.NewObject(obj)

        obj.GeneralArea = 3 * old["Area"]
        obj.Length = old["Length"]
        _wrn("New proxy class used; properties migrated\n")

        if App.GuiUp:
            vobj = obj.ViewObject
            old = dict()

            old["LineScale"] = vobj.LineScale
            vobj.removeProperty("LineScale")

            new_view.ViewProviderNew(vobj)

            vobj.LineScale = 1.05 * old["LineScale"]
            _wrn("New viewprovider class used; view properties migrated\n")
}}

Wir sehen, dass die alten Werte in einem Hilfswörterbuch gespeichert werden, dann werden die alten Eigenschaften entfernt, dann fügen wir die neue Klasse hinzu und schließlich weisen wir die zuvor gespeicherten Werte den neuen Eigenschaften zu. In diesem Moment können wir die gespeicherten Werte nach Bedarf für die neue Klasse transformieren. Beispielsweise wird {{incode|GeneralArea}} auf das Dreifache des alten {{incode|Area}} gesetzt, und das neue {{incode|Length}} erhält einfach den Wert des alten {{incode|Length}}. Da wir wissen, wie sich die alten und neuen Klassen verhalten sollen, haben wir die Freiheit, die Daten so zu manipulieren, dass das Objekt nach unseren Wünschen migriert wird.

Wir können nur Eigenschaften entfernen, die von [[Python/de|Python]]-Klassen hinzugefügt wurden, als wir das [[Scripted_objects/de|skriptgenerierte Objekt]] gebaut haben. Andere Attribute gehören zum Basis-C++-Objekt und können nicht entfernt werden.
{{Code|code=
>>> obj.removeProperty("Visibility")
False
}}

Angenommen, wir haben das alte Modul bereits auf diese Weise geändert, dann sehen wir beim Öffnen eines Dokuments mit einem alten Objekt die Meldungen, die auf die Verwendung der neuen Klassen hinweisen. Bei der Überprüfung des Objekts in der [[Python_console/de|Python-Konsole]] stellen wir fest, dass die älteren Eigenschaften entfernt wurden und nur noch die neuen Eigenschaften vorhanden sind.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.PropertiesList)
['Divisions', ..., 'GeneralArea', ..., ..., 'Length', ..., ..., ..., ...]
>>> print(obj.Proxy)
<objects.new_module.NewObject object at 0x7efd456c9b00>
}}

Da in der alten Klasse die Eigenschaft {{incode|Divisions}} nicht existierte, wurde nichts damit gemacht. Sie wurde einfach von der neuen Klasse {{incode|objects.new_module.NewObject}} erstellt.

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

* [[File:Edit_OK.svg|24px]] Ähnlich wie bei Methode 2 können wir mit dieser Methode überprüfen, ob die Klasse, die wir migrieren, die richtige Klasse ist.
* [[File:Edit_OK.svg|24px]] Wir haben die vollständige Kontrolle darüber, was mit den alten Eigenschaften geschieht. In der Regel werden sie entfernt, damit es nicht zu Namenskonflikten mit neu hinzugefügten Eigenschaften kommt. So vermeiden wir doppelte Eigenschaften.
* [[File:Edit_OK.svg|24px]] Durch das Speichern der älteren Werte können wir die Informationen im Wiederherstellungsschritt nach Belieben bearbeiten und den neuen Eigenschaften die entsprechenden Werte zuweisen.

'''Nachteile'''

* [[File:Edit_Cancel.svg|24px]] Diese Methode ist im Vergleich zu den vorherigen sehr ausführlich, da wir die Methode {{incode|onDocumentRestored}} implementieren und jede der Eigenschaften einzeln behandeln müssen (Wert speichern, Eigenschaft löschen, Wert neu zuweisen). Dies ist problematisch, wenn das Objekt, das wir migrieren möchten, viele Eigenschaften hat oder deren Werte auf ganz besondere Weise transformiert werden müssen.

<span id="Addendum_A._Creating_the_properties_only_if_they_do_not_already_exist"></span>
== Zusatz A. Erstellen der Eigenschaften nur, wenn sie noch nicht vorhanden sind ==

Einer der Nachteile von Methode 2 ist, dass sie immer versucht, die neuen Eigenschaften hinzuzufügen. Wenn die älteren Eigenschaften denselben Namen wie die neuen Eigenschaften haben, werden sie mit einer fortlaufenden Nummer dupliziert, sodass {{incode|Length}} zu {{incode|Length1}}, dann zu {{incode|Length2}} usw. führt. Dies macht Methode 2 in den meisten Fällen zu einer unrealistischen Option, da die neue Klasse ohnehin nur eine Eigenschaft verwenden wird.

Um diese Methode zu verbessern, kann die neue Klasse auch so geändert werden, dass die Eigenschaften nur hinzugefügt werden, wenn sie nicht bereits unter demselben Namen vorhanden sind.
{{Code|code=
# objects/new_module.py
class NewObject:
    def __init__(self, obj):
        if not hasattr(obj, "Length"):
            obj.addProperty("App::PropertyLength", "Length")
            obj.Length = 30
        if not hasattr(obj, "GeneralArea"):
            obj.addProperty("App::PropertyArea", "GeneralArea")
            obj.GeneralArea = 600
        if not hasattr(obj, "Divisions"):
            obj.addProperty("App::PropertyInteger", "Divisions")
            obj.Divisions = 4

        obj.Proxy = self
        self.Type = "Custom"

    def execute(self, obj):
        pass
}}

In diesem Fall wird {{incode|Length}} nicht erneut hinzugefügt, da es bereits vorhanden ist. {{incode|GeneralArea}} und {{incode|Divisions}} sind nicht vorhanden und werden daher hinzugefügt. Und wie zuvor bleibt {{incode|Area}} erhalten, da es nicht explizit entfernt wird, obwohl es in der neuen Klasse möglicherweise nicht mehr verwendet wird.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.PropertiesList)
['Area', 'Divisions', ..., 'GeneralArea', ..., ..., 'Length', ..., ..., ..., ...]
>>> print(obj.Proxy)
<objects.new_module.NewObject object at 0x7f036bd4c6a0>
}}

Das Gleiche kann für die Klasse der [[viewprovider/de|Viewprovider]] getan werden.

<div lang="en" dir="ltr" class="mw-content-ltr">
By using this method 2 + A, the result is similar to method 1 in that the object will retain all previous properties, but in addition it will gain the new properties provided by the new class.
</div>

<div lang="en" dir="ltr" class="mw-content-ltr">
Method 3 does not need this addendum to the new class because the older properties are explicitly removed, so there won't be any conflicts when installing the new properties. Nevertheless, it is still a good practice that every class adds its required properties only if these don't already exist. This is helpful both in the case of creating new [[scripted_objects|scripted objects]] or in migrating them.
</div>

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

* [[File:Edit_OK.svg|24px]] Das Objekt behält alle bisherigen Eigenschaften bei, erhält jedoch zusätzlich neue Eigenschaften ohne Wiederholungen.

'''Nachteile'''

* [[File:Edit_Cancel.svg|24px]] Wie bei Methode 2 werden umbenannte Eigenschaften weiterhin nicht berücksichtigt. Die alten Eigenschaften müssen manuell entfernt werden.

<span id="Addendum_B._Migrating_different_versions_of_the_old_object"></span>
== Zusatz B. Migrieren verschiedener Versionen des alten Objekts ==

Methode 3 ist die komplexeste Methode, da die Eigenschaften einzeln behandelt werden. Allerdings haben wir bei dieser Methode auch volle Flexibilität bei der Bearbeitung der Daten, was ein Vorteil ist, wenn wir komplexe Operationen durchführen möchten.

<div lang="en" dir="ltr" class="mw-content-ltr">
If from the beginning we create a property that holds the version number of our object, we can use this number in the future to perform specific migration from that version to any other. We set the property to be read-only, so that we cannot overwrite it in the [[property_editor|property editor]], although it is still accessible from the [[Python_console|Python console]].
</div>
{{Code|code=
# old_module.py
class OldObject:
    def __init__(self, obj):
        obj.addProperty("App::PropertyLength", "Length")
        obj.addProperty("App::PropertyArea", "Area")
        obj.addProperty("App::PropertyString", "Version")
        obj.setEditorMode("Version", 1)
        obj.Length = 15
        obj.Area = 300
        obj.Version = "0.18"
        obj.Proxy = self
        self.Type = "Custom"

    def execute(self, obj):
        pass
}}

Wenn wir dann das Objekt migrieren möchten, implementieren wir die Methode {{incode|onDocumentRestored}} und testen diese Version.
{{Code|code=
# old_module.py
import FreeCAD as App
import objects.new_module as new_module
_wrn = App.Console.PrintWarning

class OldObject:
    def onDocumentRestored(self, obj):
        if hasattr(obj, "Version") and obj.Version:
            if obj.Version == "0.18":
                _migrate_from_018(obj)
            elif obj.Version == "0.19":
                _migrate_from_019(obj)

def _migrate_from_018(obj):
    old = dict()
    old["Area"] = obj.Area
    old["Length"] = obj.Length
    obj.removeProperty("Area")
    obj.removeProperty("Length")
    obj.removeProperty("Version")

    new_module.NewObject(obj)

    obj.GeneralArea = 3 * old["Area"]
    obj.Length = old["Length"]
    obj.Version = "0.20"
    _wrn("New proxy class used; properties migrated\n")

def _migrate_from_019(obj):
    ...
}}

<div lang="en" dir="ltr" class="mw-content-ltr">
We don't save the {{incode|Version}} value as we will set a new {{incode|Version}} number when doing the migration. As shown in the example, we can implement various functions for each corresponding version of the object that we intend to migrate. We omit the migration of the [[viewprovider|viewprovider]] properties but it follows the same pattern.
</div>

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

<div lang="en" dir="ltr" class="mw-content-ltr">
* [[File:Edit_OK.svg|24px]] We have complete control of what to do with the old properties, and how to perform the migration.
* [[File:Edit_OK.svg|24px]] We can implement a particular method to migrate a particular version of the old object.
</div>

'''Nachteile'''

<div lang="en" dir="ltr" class="mw-content-ltr">
* [[File:Edit_Cancel.svg|24px]] This method is very verbose because we must have a clear idea on how to handle each of the properties of each "version" that we want to migrate. If our object has many different versions created over the years, we may have to prepare a long list of methods to migrate them to the newest object.
</div>

<span id="Addendum_B2._Using_internal_class_attributes_instead_of_properties"></span>
== Zusatz B2. Verwendung interner Klassenattribute anstelle von Eigenschaften ==

<div lang="en" dir="ltr" class="mw-content-ltr">
Instead of using a [[property|property]] of the object to hold the version information, we can use an attribute of the class. In this way we "hide" the version information, because properties are normally public, and visible in the [[property_editor|property editor]], while class attributes can only be manipulated from the [[Python_console|Python console]]. Class attributes can be saved and restored as explained in [[Scripted_objects_saving_attributes|Scripted objects saving attributes]].
</div>
{{Code|code=
# old_module.py
class OldObject:
    def __init__(self, obj):
        obj.addProperty("App::PropertyLength", "Length")
        obj.addProperty("App::PropertyArea", "Area")
        obj.Length = 15
        obj.Area = 300
        obj.Proxy = self

        self.Type = "Custom"
        self.ver = "0.18"

    def execute(self, obj):
        pass
}}

Dieses Attribut wird durch Überprüfen des Attributs {{incode|Proxy}} überprüft.
{{Code|code=
>>> obj = App.ActiveDocument.Custom
>>> print(obj.Proxy.ver)
0.18
}}

Anschließend wird die Datei geändert, um das Objekt zu migrieren.
{{Code|code=
# old_module.py
import FreeCAD as App
import objects.new_module as new_module
_wrn = App.Console.PrintWarning

class OldObject:
    def onDocumentRestored(self, obj):
        if hasattr(obj.Proxy, "ver") and obj.Proxy.ver:
            if obj.Proxy.ver == "0.18":
                _migrate_from_018(obj)

def _migrate_from_018(obj):
    old = dict()
    old["Area"] = obj.Area
    old["Length"] = obj.Length
    obj.removeProperty("Area")
    obj.removeProperty("Length")

    new_module.NewObject(obj)

    obj.GeneralArea = 3 * old["Area"]
    obj.Length = old["Length"]
    _wrn("New proxy class used; properties migrated\n")
}}

Wenn wir die neue Klasse installieren, sollte diese neue Klasse den neuen Wert des Versionsattributs festlegen, zum Beispiel <code>self.ver = "0.20"</code>.

<span id="Addendum_C._Method_3_without_removing_old_properties_that_are_named_the_same"></span>
== Zusatz C. Methode 3 ohne Entfernung alter Eigenschaften mit gleichem Namen ==

Wie in Anhang A können wir die neue Klasse so schreiben, dass Eigenschaften nur dann erstellt werden, wenn sie noch nicht vorhanden sind. Mit Methode 3 speichern wir die Werte der älteren Eigenschaften und löschen anschließend die älteren Eigenschaften. Wenn die neuen Eigenschaften jedoch denselben Namen wie die älteren haben, müssen wir die älteren nicht löschen, sondern können einfach dieselbe Eigenschaft wiederverwenden, da wir wissen, dass die Eigenschaft nicht dupliziert wird. Wenn wir Anhang B verwenden, haben wir auch die Möglichkeit, die Version abzufragen.

{{Code|code=
# old_module.py
import FreeCAD as App
import objects.new_module as new_module
_wrn = App.Console.PrintWarning

class OldObject:
    def onDocumentRestored(self, obj):
        if hasattr(obj, "Version") and obj.Version:
            if obj.Version == "0.18":
                _migrate_from_018(obj)

def _migrate_from_018(obj):
    old = dict()
    old["Area"] = obj.Area
    obj.removeProperty("Area")

    new_module.NewObject(obj)

    obj.GeneralArea = 3 * old["Area"]
    obj.Version = "0.20"
    _wrn("New proxy class used; properties migrated\n")
}}

<div lang="en" dir="ltr" class="mw-content-ltr">
As we see in the example, the old {{incode|Area}} property is deleted and migrated to the new {{incode|GeneralArea}} property as usual. We do not need to delete {{incode|Length}} nor {{incode|Version}} because in the new class they are still used with the same name, and they won't be created again (addendum A). As we don't want to modify {{incode|Length}}, this property is not touched at all; it is migrated to the new class silently. However, we do update {{incode|Version}} to the new value. We omit the migration of the [[viewprovider|viewprovider]] properties but it follows the same pattern.
</div>

<div lang="en" dir="ltr" class="mw-content-ltr">
This should work like method 3, meaning that the old properties are removed and only the new properties remain in the new object. The only difference is that we omit removing and recreating the properties that are named the same. This process should work as long as the old [[property|property]] and the new [[property|property]] have the same type (for example, {{incode|App::PropertyLength}} or {{incode|App::PropertyArea}}), so the old property can pass its value directly. However, if the new property has a different type than the old property, then the old property should be removed, otherwise the old property will completely overwrite the new property, which is probably not what we want because the new class will be expecting the new type and not the old type.
</div>

<span id="Advantages_and_disadvantages"></span>
=== Vor- und Nachteile ===

'''Vorteile'''

* [[File:Edit_OK.svg|24px]] Wie bei Methode 3 ermöglicht uns diese Methode die vollständige Kontrolle über die Migration der alten Informationen.
* [[File:Edit_OK.svg|24px]] Wir vermeiden es, Code zu schreiben, der Eigenschaften mit demselben Namen entfernt und neu erstellt.

'''Nachteile'''

* [[File:Edit_Cancel.svg|24px]] Wie Methode 3 ist auch diese Methode sehr ausführlich, da wir die Eigenschaften sorgfältig behandeln müssen.
* [[File:Edit_Cancel.svg|24px]] Wenn eine neue [[Property/de|Eigenschaft]] und eine alte [[Property/de|Eigenschaft]] denselben Namen haben, wird die neue Eigenschaft überschrieben, was insbesondere dann unerwünscht sein kann, wenn die beiden Eigenschaften unterschiedliche Typen haben. In diesem Fall ist es weiterhin erforderlich, die alte Eigenschaft zu entfernen und ihren Wert manuell zu migrieren.

<span id="Summary"></span>
== Zusammenfassung ==

Jede der Methoden hat eine empfohlene Anwendung:
* Methode 1. Das Modul wird verschoben oder umbenannt, aber die Eigenschaften sind die gleichen. Einfache Umleitung von Klassen, da die Eigenschaften überhaupt nicht geändert werden müssen.
* Methode 2+A. Einfache Migrationsszenarien. Anzeige einer Nachricht, wenn das Objekt von einer Klasse in eine andere migriert wird. Die Eigenschaften sind vom gleichen Typ und brauchen überhaupt nicht geändert zu werden.
* Methode 3, 3+A oder 3+B. Komplexe Migrationsszenarien. Volle Kontrolle über die Eigenschaften, Löschen der alten Eigenschaften und Hinzufügen neuer Eigenschaften. Ein Identifikator zur Kenntnis der Version des Objekts ist nützlich, um die richtige Funktion zur Durchführung der Migration zu wählen (Zusatz B oder B2).

Vermeide vorzugsweise Folgendes:
* Methode 2. Die Eigenschaften werden dupliziert, wenn die neue Klasse nicht auf vorhandene Eigenschaften prüft (Zusatz A).
* Methode 3+C. Nur verwenden, wenn die alten Eigenschaften und die neuen Eigenschaften vom gleichen Typ sind. Andernfalls verwende Methode 3 oder 3+B, um ältere Eigenschaften zu entfernen, und behandele sie genau nach Bedarf.

<span id="Links"></span>
== Verweise ==

* [https://forum.freecad.org/viewtopic.php?t=42948 Migrating and upgrading old scripted objects]
* [https://forum.freecad.org/viewtopic.php?f=18&t=46218 Migrate old scripted objects]

{{Powerdocnavi{{#translation:}}}}
[[Category:Developer Documentation{{#translation:}}]]
[[Category:Python Code{{#translation:}}]]
{{clear}}