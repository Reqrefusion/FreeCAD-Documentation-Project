<languages/>
{{TOCright}}

<span id="Introduction"></span>
==Wprowadzenie==

Ta strona przedstawia przykłady o średnim poziomie zaawansowania menedżera GUI [[PySide/pl|PySide]] (strony towarzyszące obejmują zagadnienia mniej lub bardziej zaawansowane: [[PySide_Beginner_Examples/pl|Podstawowe przykłady PySide]] oraz [[PySide_Advanced_Examples/pl|Zaawansowane przykłady PySide]]). Na tej stronie wykorzystano przykładowy program do omówienia różnych tematów związanych z PySide. Celem jest przedstawienie działającego kodu PySide, tak aby każdy, kto potrzebuje korzystać z PySide, mógł skopiować odpowiednią część, zmodyfikować ją i dostosować do własnych potrzeb.

<span id="Notes"></span>
===Uwagi=== 

* Ta strona nie ma na celu omawiania języka Python ani pełnienia roli instrukcji w Pythonie.
* Nazwy zmiennych nie są opisowe, lecz zachowano ich kolejność, aby lepiej zorganizować wyjaśnienia.
* Istnieje wiele konwencji nazewnictwa dla komponentów GUI, z których żadna nie jest "prawidłowa" ani "błędna".
* Istnieje wiele różnych kolejności deklaracji widżetów, sygnałów i metod; ponownie, żadna nie jest "prawidłowa" ani "błędna".
* Warto pamiętać, że PySide operuje na ciągach znaków przy obsłudze danych wejściowych od użytkownika; to, co na ekranie wygląda jak liczba, jest w rzeczywistości reprezentacją tekstową liczby.

<span id="Code_Based_Discussion_-_Declarative_Portion"></span>
==Dyskusja oparta na kodzie - część deklaratywna==

"Przykładowy program" jest w rzeczywistości dużą definicją klasy, definicją klasy GUI PySide, i zawiera ponad 150 linii kodu (łącznie z komentarzami). Klasa ani jej zachowanie nie mają funkcjonalnego celu; jedynym celem jest pokazanie możliwych działań GUI oraz przedstawienie kodu, który, miejmy nadzieję, może być wykorzystany przez innych użytkowników FreeCAD.

Definicja klasy oraz niewielka liczba linii kodu, które ją wywołują, są opisane w kolejności, w jakiej występują w pliku. Kolejność ta opiera się na układzie ekranu, który jest dość dowolny i ma jedynie na celu pokazanie funkcji. Oto modalny ekran GUI generowany przez klasę PySide:

[[File:PySideScreenSnapshot3.jpg]]

Większa część pozostałej części tej sekcji opisuje zawartość definicji klasy, która znajduje się na końcu tej sekcji. Najpierw omówimy elementy deklaratywne, które definiują sposób działania i sposób składania GUI, a następnie przejdziemy do sekcji operacyjnych (czyli kodu, który zostanie wykonany w trakcie interakcji użytkownika). To okno opiera się na klasie QDialog, więc jest modalne – co oznacza, że nie można wykonywać żadnych działań poza oknem, dopóki jest ono otwarte.

<span id="Import_Statement"></span>
==Określenie importu==

Obowiązkowe określenie importu

{{Code|code=
from PySide import QtGui, QtCore
}}

Najlepiej to umieścić w górnej części pliku Pythona.

<span id="Class_Definition"></span>
===Definicja klasy===

{{Code|code=
class ExampleModalGuiClass(QtGui.QDialog):
	""""""
	def __init__(self):
		super(ExampleModalGuiClass, self).__init__()
		self.initUI()
	def initUI(self):
}}

Ten kod najlepiej skopiować w całości i następnie zmodyfikować. Istota kodu polega na tym, że tworzymy podklasę klasy QDialog z PySide. Przy dostosowywaniu tego kodu warto zmienić nazwę klasy "ExampleModalGuiClass" – upewnij się, że zmienisz ją w obu miejscach (np. linie 1 i 4).

<span id="Window_Return_Status"></span>
===Status zwracany przez okno===

{{Code|code=
self.result = userCancelled
}}

Nie jest to obowiązkowe, lecz stanowi dobrą praktykę programistyczną - ustawia domyślny status zwracany przez okno, który będzie obecny niezależnie od działań użytkownika. Później w kodzie status ten może zostać zmieniony przez kod Pythona, aby wskazać różne opcje wybrane przez użytkownika.

<span id="Window_Creation"></span>
===Tworzenie okna===

{{Code|code=
# create our window
# define window		xLoc,yLoc,xDim,yDim
self.setGeometry(	250, 250, 400, 350)
self.setWindowTitle("Our Example Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
}}

Mając na uwadze, że wymiary ekranu mierzone są od lewego górnego rogu, w 3. linii wartości odnoszą się do:
* liczby pikseli, o jakie lewy górny róg będzie odsunięty w prawo od lewego krawędzi ekranu (250)
* liczby pikseli, o jakie lewy górny róg będzie odsunięty w dół od górnej krawędzi ekranu (250)
* szerokości okna w pikselach (400)
* wysokości okna w pikselach (350)
Tytuł okna jest ustawiony, a ostatnia linia oznacza po prostu, że to okno nigdy nie zostanie zasłonięte przez inne okno - jeśli nie jest to pożądane, wystarczy umieścić znak komentarza Pythona ('#') jako pierwszy znak tej linii.

<span id="Label_Creation"></span>
===Tworzenie etykiety===

{{Code|code=
# create some Labels
self.label1 = QtGui.QLabel("                       ", self)
self.label1.setFont('Courier') # set to a non-proportional font
self.label1.move(20, 20)
self.label2 = QtGui.QLabel("sample string number two", self)
self.label2.move(20, 70)
self.label3 = QtGui.QLabel("                        ", self)
self.label3.setFont('Courier') # set to a non-proportional font
self.label3.move(20, 120)
self.label4 = QtGui.QLabel("can you see this?", self)
self.label4.move(20, 170)
}}

W PySide etykiety pełnią dwie funkcje: statyczne etykiety (jak sama nazwa wskazuje) oraz pola tekstowe tylko do odczytu (czyli wyłącznie do wyświetlania). Dzięki temu można przekazywać użytkownikowi zarówno niezmienne instrukcje, takie jak "Nie naciskaj czerwonego przycisku", jak i dynamiczne wyniki obliczeń, np. "42". Druga linia deklaruje etykietę i ustawia jej wartość początkową (w tym przypadku pustą). Trzecia linia określa czcionkę - można podać dowolną czcionkę dostępną w systemie, a jeśli nie zostanie określona, używana jest czcionka domyślna. W tym przypadku czcionka jest ustawiona jako nieproporcjonalna. Etykieta jest następnie przesuwana do swojej pozycji w oknie - jej współrzędne określają pozycję względem okna, a nie ekranu.

<span id="Checkbox_Creation"></span>
===Tworzenie przycisku wyboru===

{{Code|code=
# checkboxes
self.checkbox1 = QtGui.QCheckBox("Left side", self)
self.checkbox1.clicked.connect(self.onCheckbox1)
#self.checkbox1.toggle() # will set an initial value if executed
self.checkbox1.move(210,10)
#
self.checkbox2 = QtGui.QCheckBox("Right side", self)
self.checkbox2.clicked.connect(self.onCheckbox2)
self.checkbox2.move(210,30)
}}

Przyciski wyboru mogą być włączone lub wyłączone w dowolnej kombinacji (w przeciwieństwie do przycisków radiowych). Linia 2 deklaruje pole wyboru i ustawia jego wartość początkową. Linia 3 określa, która metoda zostanie wywołana po kliknięciu pola wyboru (w tym przypadku metoda 'onCheckBox1'). Gdyby linia 4 nie zaczynała się od znaku komentarza Pythona ('#'), zostałaby wykonana i zaznaczyłaby pole wyboru. Wreszcie, linia 5 ustawia pozycję pola wyboru w oknie.

<span id="Radio_Button_Creation"></span>
===Tworzenie przycisku radiowego===

{{Code|code=
# radio buttons
self.radioButton1 = QtGui.QRadioButton("random string one",self)
self.radioButton1.clicked.connect(self.onRadioButton1)
self.radioButton1.move(210,60)
#
self.radioButton2 = QtGui.QRadioButton("owt gnirts modnar",self)
self.radioButton2.clicked.connect(self.onRadioButton2)
self.radioButton2.move(210,80)
}}

Tworzenie przycisków radiowych jest bardzo podobne do przycisków wyboru. Jedyną istotną różnicą jest ich zachowanie - w danym momencie może być włączony tylko jeden przycisk radiowy.

<span id="Pop-Up_Menu_Creation"></span>
===Tworzenie wyskakującego menu===

{{Code|code=
# set up lists for pop-ups
self.popupItems1 = ("pizza","apples","candy","cake","potatoes")
# set up pop-up menu
self.popup1 = QtGui.QComboBox(self)
self.popup1.addItems(self.popupItems1)
self.popup1.setCurrentIndex(self.popupItems1.index("candy"))
self.popup1.activated[str].connect(self.onPopup1)
self.popup1.move(210, 115)
}}

W linii 2 tworzona jest lista opcji, z których użytkownik będzie mógł wybierać. Alternatywnie można utworzyć słownik, wykorzystując jednak wyłącznie klucze jako listę opcji menu. Linia 4 tworzy menu rozwijane (w PySide znane jako ComboBox), a linia 5 dodaje do niego opcje użytkownika.

Jako uwaga dodatkowa, gdyby użyto słownika, linie wyglądałyby następująco:

{{Code|code=
self.popupItems1 = OrderedDict([("2","widget"),("pink","foobar"),("4","galopsis")])

self.popup1.addItems(self.popupItems1.keys())
}}

Wracając do głównego przykładu kodu w tej sekcji, linia 6 ustawia wartość domyślną - można ją pominąć, a wartość domyślnego wyboru można również wczytać do odpowiadającej etykiety (jeśli jest to stosowne). Wreszcie, linia 8 ustawia pozycję elementu w oknie.

<span id="Button_Creation_Part_1"></span>
===Tworzenie przycisku część 1===

{{Code|code=
# toggle visibility button
pushButton1 = QtGui.QPushButton('Toggle visibility', self)
pushButton1.clicked.connect(self.onPushButton1)
pushButton1.setAutoDefault(False)
pushButton1.move(210, 165)
}}

Przycisk jest tworzony w linii 2 wraz z jego nazwą, natomiast obsługa sygnału po kliknięciu określona jest w linii 3. Linia 4 zapobiega ustawieniu przycisku jako 'domyślnego' - czyli takiego, który zostanie kliknięty, gdy użytkownik naciśnie klawisz {{KEY|Powrót}}. Na końcu element jest przenoszony do odpowiedniej pozycji w oknie, co kończy segment kodu.

<span id="Button_Creation_Part_2"></span>
===Tworzenie przycisku część 2===

{{Code|code=
# cancel button
cancelButton = QtGui.QPushButton('Cancel', self)
cancelButton.clicked.connect(self.onCancel)
cancelButton.setAutoDefault(True)
cancelButton.move(150, 280)
# OK button
okButton = QtGui.QPushButton('OK', self)
okButton.clicked.connect(self.onOk)
okButton.move(260, 280)
}}

Oba przyciski są tworzone z nazwą (która pojawi się jako ich etykieta), powiązane z metodą, która zostanie wykonana po kliknięciu, i przeniesione do odpowiedniej pozycji. Wyjątkiem jest linia 4, która ustawia przycisk 'Anuluj' jako przycisk domyślny – oznacza to, że zostanie "kliknięty", jeśli użytkownik naciśnie klawisz {{KEY|Powrót}}.

<span id="Text_Input_Creation"></span>
===Tworzenie pola tekstowego===

{{Code|code=
# text input field
self.textInput = QtGui.QLineEdit(self)
self.textInput.setText("cats & dogs")
self.textInput.setFixedWidth(190)
self.textInput.move(20, 220)
}}

Widżet QLineEdit jest prawdopodobnie najczęściej używanym do wprowadzania tekstu przez użytkownika. W tym przykładzie kolejna sekcja kodu ustawi dla niego menu kontekstowe. Ta sekcja kodu: tworzy widżet (linia 2), ustawia wartość początkową (linia 3), określa szerokość pola (linia 4) i przenosi widżet na właściwe miejsce (linia 5).

<span id="QuantitySpinBox_Creation"></span>
===Tworzenie QuantitySpinBox===

{{Code|code=
# QuantitySpinBox
from FreeCAD import Units
ui = FreeCADGui.UiLoader()
quantityInput = ui.createWidget("Gui::QuantitySpinBox")
self.quantityInput.setProperty( 'minimum', 0.0)
potential = 2.87
unit = "V"
# only set the value
self.quantityInput.setProperty('rawValue', potential )
# set quantity (value + unit)
quantity = Units.Quantity("{} {}".format(potential , unit))
self.quantityInput.setProperty('value', quantity)
# read value from the spinbox
quantity = self.quantityInput.property('value')
}}

Widżet Gui::QuantitySpinBox jest specjalnym elementem FreeCAD, zaprojektowanym do wyświetlania i obsługi wartości wraz z ich [[Expressions/pl#Jednostki|jednostkami]]. Pochodzi on z klasy Qt [https://doc.qt.io/qt-5/qabstractspinbox.html QAbstractSpinBox class]. Aby zobaczyć wszystkie jego właściwości, sprawdź listę w pliku źródłowym [https://github.com/FreeCAD/FreeCAD/blob/master/src/Gui/QuantitySpinBox.h#L42 QuantitySpinBox.h].

<span id="Contextual_Menu_Creation"></span>
===Tworzenie menu kontekstowego===

{{Code|code=
# set contextual menu options for text editing widget
# set text field to some dogerel
popMenuAction1 = QtGui.QAction(self)
popMenuAction1.setText("load some text")
popMenuAction1.triggered.connect(self.onPopMenuAction1)
# make text uppercase
popMenuAction2 = QtGui.QAction(self)
popMenuAction2.setText("uppercase")
popMenuAction2.triggered.connect(self.onPopMenuAction2)
# menu dividers
popMenuDivider = QtGui.QAction(self)
popMenuDivider.setText('---------')
popMenuDivider.triggered.connect(self.onPopMenuDivider)
# remove all text
popMenuAction3 = QtGui.QAction(self)
popMenuAction3.setText("clear")
popMenuAction3.triggered.connect(self.onPopMenuAction3)
# define menu and add options
self.textInput.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
self.textInput.addAction(popMenuAction1)
self.textInput.addAction(popMenuAction2)
self.textInput.addAction(popMenuDivider)
self.textInput.addAction(popMenuAction3)
}}

Ten kod zawiera liczne powtórzenia, ponieważ ta sama akcja jest wykonywana dla różnych wartości - to jedna z przyczyn, dla których kod GUI jest tak obszerny (bez względu na system). Najpierw tworzony jest obiekt QAction - jest to powiązanie tekstu, który użytkownik zobaczy jako opcję do wyboru, z metodą, która zostanie wykonana, jeśli użytkownik wybierze tę opcję. W praktyce jest to sparowanie wyboru użytkownika z fragmentem kodu. Linia 3 tworzy obiekt, linia 4 definiuje opcję użytkownika (tak jak ją zobaczy), a linia 5 określa, który fragment kodu Pythona zostanie wykonany.

Przechodząc do linii 19 (tej z "self.textInput.setContextMenuPolicy"), tworzony jest ActionsContextMenu, który jest kontenerem dla wszystkich oddzielnych powiązań QAction między wyborem użytkownika a kodem do wykonania. Każdy widżet może mieć tylko jedno menu kontekstowe (czyli menu wywoływane prawym przyciskiem myszy), więc linia 19 definiuje to menu. Następne 4 linie dodają powiązania utworzone na początku tej sekcji kodu. Kolejność ma tutaj znaczenie - użytkownik zobaczy opcje menu w kolejności, w jakiej zostały dodane. Zauważ, że trzecia opcja menu jest właściwie niczym - jej kod jest pusty, ale służy do oddzielenia dwóch grup opcji w menu kontekstowym.

<span id="Numeric_Input_Creation"></span>
===Tworzenie pola liczbowego===

{{Code|code=
# numeric input field
self.numericInput = QtGui.QLineEdit(self)
self.numericInput.setInputMask("999")
self.numericInput.setText("000")
self.numericInput.setFixedWidth(50)
self.numericInput.move(250, 220)
}}

Tworzenie pola do wprowadzania danych liczbowych w zasadzie przebiega tak samo, jak w przypadku pola tekstowego omówionego wcześniej. W rzeczywistości kod jest identyczny, z wyjątkiem linii 3 i 4. Linia 3 ustawia Maskę zdefiniowaną przez PySide, która w tym przypadku określa maksymalnie 3 cyfry (w tym również 0). Pełną listę kodów InputMask można znaleźć na stronie [http://doc.qt.io/qt-5/qlineedit.html#inputMask-prop QLineEdit InputMask].

<span id="Window_Display"></span>
===Wyświetlanie okna===

{{Code|code=
# now make the window visible
self.show()
}}

Jest tylko jedna linia i powoduje, że GUI jest wyświetlane po konfiguracji.

<span id="Code_Based_Discussion_-_Operative_Portion"></span>
==Dyskusja oparta na kodzie - część operacyjna==

We now move onto the operative portion of the GUI definition which is the code that executes in response to user interactions with the GUI. The order of statement groups is not very relevant - with the caveat that something must be declared before it can be referenced. Some people put all the handlers of a certain type (e.g. handlers for buttons) in one group, others list the handlers alphabetically. For specific application there may be a problem related reason that all handlers relating to a specific aspect be gathered together

There is a high degree of similarity between the handlers. Most do not receive a parameter, the fact they are executing is realy the only parameter (or signal) they get. Others like "onPopup1" and "mousePressEvent" accept a parameter.

There must be a one to one correspondance between the handlers specified in the declarative section and the handler declared in this, the operative section. There may be extra handlers declared which are never invoked but there may not be any missing.

===Generic Handler===

In this code example, generic handlers handle the following events:

* onCheckbox1
* onCheckbox2
* onRadioButton1
* onRadioButton2
* onPushButton1
* onPopMenuAction1
* onPopMenuAction2
* onPopMenuDivider
* onPopMenuAction3
* onCancel
* onOk

The general form for the handlers is:

{{Code|code=
def handlerName(self):
	lineOfCode1
	lineOfCode2
}}

The first line has the keyword "def" followed by the handler name. The handler name must match the name from the earlier declarative section exactly. The parameter "self" is part of the standard syntax as are the enclosing parenthesis and the final colon character. Once the first line is finished then there are no requirements of the following code, it is purely application specific.

===Pop-Up Menu Handler===

{{Code|code=
def onPopup1(self, selectedText):
}}

The Pop-Up menu handler is the same as the generic handler with exception that a second parameter, the text selected by the user, is passed in. Remember that everything is text coming from the Pop-Up menu and even if the user has selected the number 3, it will be passed in as the string "3".

===Mouse Event Handler===

{{Code|code=
def mousePressEvent(self, event):
	# print mouse position, X & Y
	print("X = ", event.pos().x())
	print("Y = ", event.pos().y())
	#
	if event.button() == QtCore.Qt.LeftButton:
		print("left mouse button")
	if self.label1.underMouse():
		print("over the text '"+self.label1.text()+"'")
}}

The Mouse Event handler is the same as the generic handler with exception that a second parameter, the mouse event (e.g. left-click, right-click) from the user is passed  in. The name of the handler, "mousePressEvent", is reserved and if it is changed then the handler will no longer receive the event from the mouse presses.

The X and Y coordinates of the mouse press are given by the reference "event.pos().x()" and "event.pos().y()". The constants "QtCore.Qt.LeftButton" and "QtCore.Qt.RightButton" are used to determine which mouse button was pressed.

A reference to a widget can be made of the form "self.widgetName.underMouse()" which will return {{TRUE}} or {{FALSE}} as to whether the mouse cursor is over the widget "widgetName". Although presented in the same code excerpt the "underMouse()" handler is not tied to the "mousePressEvent" handler and can be used at any time.

==Code Based Discussion - Main Routine==

Most of the volume of code is in the GUI Class definition, there is not much in the main procedure.

{{Code|code=
# Constant definitions
global userCancelled, userOK
userCancelled = "Cancelled"
userOK = "OK"
}}

Lines 2,3 & 4 deal with coordinating the status of the user interaction with the GUI - e.g. Cancelled, OK, or any other application defined status. The handler routines "onCancel" and "onOk" earlier also set these statuses.

{{Code|code=
form = ExampleGuiClass()
form.exec_()

if form.result==userCancelled:
	pass # steps to handle user clicking Cancel
if form.result==userOK:
	# steps to handle user clicking OK
	localVariable1 = form.label1.text()
	localVariable2 = form.label2.text()
	localVariable3 = form.label3.text()
	localVariable4 = form.label4.text()
}}

Lines 1 and 2 show the method for invoking the GUI. There may be multiple GUI definitions for a program and also the GUI need not be invoked as the first thing in the Python file, it may be invoked at any point. The Name of the GUI Class is specified in line 1 ("ExampleGuiClass" in this case) but the rest of the 2 lines are to be copied verbatim.

Lines 4 and 6 use the result field to determine the appropriate action. The last 4 lines simply show the copying of the data in the GUI object to variables local to the executing main procedure.

==Complete Modal Code Example==

This is the complete code example (developed on FreeCAD v0.14):

{{Code|code=
# import statements
from PySide import QtGui, QtCore

# UI Class definitions

class ExampleModalGuiClass(QtGui.QDialog):
	""""""
	def __init__(self):
		super(ExampleModalGuiClass, self).__init__()
		self.initUI()
	def initUI(self):
		self.result = userCancelled
		# create our window
		# define window		xLoc,yLoc,xDim,yDim
		self.setGeometry(	250, 250, 400, 350)
		self.setWindowTitle("Our Example Modal Program Window")
		self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		# create some Labels
		self.label1 = QtGui.QLabel("                       ", self)
		self.label1.setFont('Courier') # set to a non-proportional font
		self.label1.move(20, 20)
		self.label2 = QtGui.QLabel("sample string number two", self)
		self.label2.move(20, 70)
		self.label3 = QtGui.QLabel("                        ", self)
		self.label3.setFont('Courier') # set to a non-proportional font
		self.label3.move(20, 120)
		self.label4 = QtGui.QLabel("can you see this?", self)
		self.label4.move(20, 170)
		# checkboxes
		self.checkbox1 = QtGui.QCheckBox("Left side", self)
		self.checkbox1.clicked.connect(self.onCheckbox1)
		#self.checkbox1.toggle() # will set an initial value if executed
		self.checkbox1.move(210,10)
		#
		self.checkbox2 = QtGui.QCheckBox("Right side", self)
		self.checkbox2.clicked.connect(self.onCheckbox2)
		self.checkbox2.move(210,30)
		# radio buttons
		self.radioButton1 = QtGui.QRadioButton("random string one",self)
		self.radioButton1.clicked.connect(self.onRadioButton1)
		self.radioButton1.move(210,60)
		#
		self.radioButton2 = QtGui.QRadioButton("owt gnirts modnar",self)
		self.radioButton2.clicked.connect(self.onRadioButton2)
		self.radioButton2.move(210,80)
		# set up lists for pop-ups
		self.popupItems1 = ("pizza","apples","candy","cake","potatoes")
		# set up pop-up menu
		self.popup1 = QtGui.QComboBox(self)
		self.popup1.addItems(self.popupItems1)
		self.popup1.setCurrentIndex(self.popupItems1.index("candy"))
		self.popup1.activated[str].connect(self.onPopup1)
		self.popup1.move(210, 115)
		# toggle visibility button
		pushButton1 = QtGui.QPushButton('Toggle visibility', self)
		pushButton1.clicked.connect(self.onPushButton1)
		pushButton1.setAutoDefault(False)
		pushButton1.move(210, 165)
		# text input field
		self.textInput = QtGui.QLineEdit(self)
		self.textInput.setText("cats & dogs")
		self.textInput.setFixedWidth(190)
		self.textInput.move(20, 220)
		# set contextual menu options for text editing widget
		# set text field to some dogerel
		popMenuAction1 = QtGui.QAction(self)
		popMenuAction1.setText("load some text")
		popMenuAction1.triggered.connect(self.onPopMenuAction1)
		# make text uppercase
		popMenuAction2 = QtGui.QAction(self)
		popMenuAction2.setText("uppercase")
		popMenuAction2.triggered.connect(self.onPopMenuAction2)
		# menu dividers
		popMenuDivider = QtGui.QAction(self)
		popMenuDivider.setText('---------')
		popMenuDivider.triggered.connect(self.onPopMenuDivider)
		# remove all text
		popMenuAction3 = QtGui.QAction(self)
		popMenuAction3.setText("clear")
		popMenuAction3.triggered.connect(self.onPopMenuAction3)
		# define menu and add options
		self.textInput.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
		self.textInput.addAction(popMenuAction1)
		self.textInput.addAction(popMenuAction2)
		self.textInput.addAction(popMenuDivider)
		self.textInput.addAction(popMenuAction3)
		# numeric input field
		self.numericInput = QtGui.QLineEdit(self)
		self.numericInput.setInputMask("999")
		self.numericInput.setText("000")
		self.numericInput.setFixedWidth(50)
		self.numericInput.move(250, 220)
		# cancel button
		cancelButton = QtGui.QPushButton('Cancel', self)
		cancelButton.clicked.connect(self.onCancel)
		cancelButton.setAutoDefault(True)
		cancelButton.move(150, 280)
		# OK button
		okButton = QtGui.QPushButton('OK', self)
		okButton.clicked.connect(self.onOk)
		okButton.move(260, 280)
		# now make the window visible
		self.show()
		#
	def onCheckbox1(self):
		text = self.label1.text()
		if text[0]==' ':
			self.label1.setText('left'+text[4:])
		else:
			self.label1.setText('    '+text[4:])
	def onCheckbox2(self):
		text = self.label1.text()
		if text[-1]==' ':
			self.label1.setText(text[:-5]+'right')
		else:
			self.label1.setText(text[:-5]+'     ')
	def onRadioButton1(self):
		self.label2.setText(self.radioButton1.text())
	def onRadioButton2(self):
		self.label2.setText(self.radioButton2.text())
	def onPopup1(self, selectedText):
		if self.label3.text().isspace():
			self.label3.setText(selectedText)
		else:
			self.label3.setText(self.label3.text()+","+selectedText)
	def onPushButton1(self):
		if self.label4.isVisible():
			self.label4.hide()
		else:
			self.label4.show()
	def onPopMenuAction1(self):
		# load some text into field
		self.textInput.setText("Lorem ipsum dolor sit amet")
	def onPopMenuAction2(self):
		# set text in field to uppercase
		self.textInput.setText(self.textInput.text().upper())
	def onPopMenuDivider(self):
		# this option is the divider and is really there as a spacer on the menu list
		# consequently it has no functional code to execute if user selects it
		pass
	def onPopMenuAction3(self):
		# clear the text from the field
		self.textInput.setText('')
	def onCancel(self):
		self.result			= userCancelled
		self.close()
	def onOk(self):
		self.result			= userOK
		self.close()
	def mousePressEvent(self, event):
		# print mouse position, X & Y
		print("X = ", event.pos().x())
		print("Y = ", event.pos().y())
		#
		if event.button() == QtCore.Qt.LeftButton:
			print("left mouse button")
		if self.label1.underMouse():
			print("over the text '"+self.label1.text()+"'")
		if self.label2.underMouse():
			print("over the text '"+self.label2.text()+"'")
		if self.label3.underMouse():
			print("over the text '"+self.label3.text()+"'")
		if self.label4.underMouse():
			print("over the text '"+self.label4.text()+"'")
		if self.textInput.underMouse():
			print("over the text '"+self.textInput.text()+"'")
		if event.button() == QtCore.Qt.RightButton:
			print("right mouse button")
# Class definitions

# Function definitions

# Constant definitions
userCancelled = "Cancelled"
userOK = "OK"

# code ***********************************************************************************

form = ExampleModalGuiClass()
form.exec_()

if form.result==userCancelled:
	pass # steps to handle user clicking Cancel
if form.result==userOK:
	# steps to handle user clicking OK
	localVariable1 = form.label1.text()
	localVariable2 = form.label2.text()
	localVariable3 = form.label3.text()
	localVariable4 = form.label4.text()
#
#OS: Mac OS X
#Word size: 64-bit
#Version: 0.14.3703 (Git)
#Branch: releases/FreeCAD-0-14
#Hash: c6edd47334a3e6f209e493773093db2b9b4f0e40
#Python version: 2.7.5
#Qt version: 4.8.6
#Coin version: 3.1.3
#SoQt version: 1.5.0
#OCC version: 6.7.0
#
}}

The best way to use this code is to copy it into an editor or FreeCAD macro file and play around with it.

==Code Based Discussion - Nonmodal Code Example==

All of the widget specific from the previous modal example transfer to use in a nonmodal window. The main difference is that the nonmodal window does not restrict the user from interacting with other windows. Basically, a nonmodal window is one that can be opened and left open for as long as needed without it placing any restrictions on other application windows. There are a small number of code differences between the two which will be highlighted, consequently this code example is quite brief. Anything that is the same as the previous modal example will be left out in the interests of keeping this overview brief. This is the nonmodal GUI screen the PySide Class generates:

[[File:PySideScreenSnapshot4.jpg]]

===Import Statement===

The mandatory Import statement

{{Code|code=
from PySide import QtGui, QtCore
}}

This is best placed at the top of the Python file.

===Class Definition===

{{Code|code=
class ExampleNonmodalGuiClass(QtGui.QMainWindow):
	""""""
	def __init__(self):
		super(ExampleNonmodalGuiClass, self).__init__()
		self.initUI()
	def initUI(self):
}}

This code is best copied out verbatim and altered. The gist of the code is that we are sub-classing the QMainWindow Class of PySide. In adapting this code you will want to change the class name "ExampleNonmodalGuiClass" - make sure to change it in both locations (e.g. lines 1 & 4).

===Window Creation===

{{Code|code=
# create our window
# define window	xLoc,yLoc,xDim,yDim
self.setGeometry(	250, 250, 400, 150)
self.setWindowTitle("Our Example Nonmodal Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
self.setMouseTracking(True)
}}

Obviously our window dimensions and title are different. The main point to note is the last line which lets PySide know that it is to send out mouse position events as they happen. Note that these events will not be sent out when the mouse is over a widget like a button as the widget will capture the events.

===Mouse Move Event Handler===

{{Code|code=
def mouseMoveEvent(self,event):
	self.label6.setText("X: "+str(event.x()) + " Y: "+str(event.y()))
}}

This handler receives the event of a Mouse Move and displays the formatted form of it. Test what happens when it is over widgets or outside of the window.

===Invoking the Window===

{{Code|code=
form = ExampleNonmodalGuiClass()
}}

Invoking the window is another area of difference from the previous example. This time only 1 line is needed for invoking the GUI.

==Complete Nonmodal Code Example==

{{Code|code=
from PySide import QtGui, QtCore

# UI Class definitions

class ExampleNonmodalGuiClass(QtGui.QMainWindow):
	""""""
	def __init__(self):
		super(ExampleNonmodalGuiClass, self).__init__()
		self.initUI()
	def initUI(self):
		self.result = userCancelled
		# create our window
		# define window		xLoc,yLoc,xDim,yDim
		self.setGeometry(	250, 250, 400, 150)
		self.setWindowTitle("Our Example Nonmodal Program Window")
		self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		self.setMouseTracking(True)
		# create Labels
		self.label4 = QtGui.QLabel("can you see this?", self)
		self.label4.move(20, 20)
		self.label5 = QtGui.QLabel("Mouse position:", self)
		self.label5.move(20, 70)
		self.label6 = QtGui.QLabel("               ", self)
		self.label6.move(135, 70)
		# toggle visibility button
		pushButton1 = QtGui.QPushButton('Toggle visibility', self)
		pushButton1.clicked.connect(self.onPushButton1)
		pushButton1.setMinimumWidth(150)
		#pushButton1.setAutoDefault(False)
		pushButton1.move(210, 20)
		# cancel button
		cancelButton = QtGui.QPushButton('Cancel', self)
		cancelButton.clicked.connect(self.onCancel)
		cancelButton.setAutoDefault(True)
		cancelButton.move(150, 110)
		# OK button
		okButton = QtGui.QPushButton('OK', self)
		okButton.clicked.connect(self.onOk)
		okButton.move(260, 110)
		# now make the window visible
		self.show()
		#
	def onPushButton1(self):
		if self.label4.isVisible():
			self.label4.hide()
		else:
			self.label4.show()
	def onCancel(self):
		self.result			= userCancelled
		self.close()
	def onOk(self):
		self.result			= userOK
		self.close()
	def mouseMoveEvent(self,event):
		self.label6.setText("X: "+str(event.x()) + " Y: "+str(event.y()))
# Class definitions

# Function definitions

# Constant definitions
global userCancelled, userOK
userCancelled		= "Cancelled"
userOK			= "OK"

# code ***********************************************************************************

form = ExampleNonmodalGuiClass()
#
#OS: Mac OS X
#Word size: 64-bit
#Version: 0.14.3703 (Git)
#Branch: releases/FreeCAD-0-14
#Hash: c6edd47334a3e6f209e493773093db2b9b4f0e40
#Python version: 2.7.5
#Qt version: 4.8.6
#Coin version: 3.1.3
#SoQt version: 1.5.0
#OCC version: 6.7.0
}}

==Misc Additional Topics==

There are 3 concepts to the screen real estate in a GUI environment:
* physical space on the screen
* frame
* geometry
Within the software all are measured in pixels. PySide has function to measure in real world units but these are undependable as the manufacturers have no standard for pixel size or aspect ratio.

The Frame is the size of a window including it's side bars, top bar (possibly with a menu in it) and bottom bar. The Geometry is the space lying within the Frame and so is always less than or equal to the Frame. In turn the Frame is always less than or equal to the available screen size.

===Available Screen Size===

{{Code|code=
# get screen dimensions (Available Screen Size)
screenWidth		= QtGui.QDesktopWidget().screenGeometry().width()
screenHeight		= QtGui.QDesktopWidget().screenGeometry().height()
# get dimensions for available space on screen
availableWidth		= QtGui.QDesktopWidget().availableGeometry().width()
availableHeight		= QtGui.QDesktopWidget().availableGeometry().height()
}}

Generally the "availableHeight" should be less than the "screenHeight" by the height of the menu bar. These 4 values are based on the hardware environment and will change from computer to computer. They are not dependent on any application window size.

(Since Python 3.9 this warning appears when the above code is executed: '''DeprecationWarning: QDesktopWidget.screenGeometry(int screen) const is deprecated'''. A replacement seems to be needed from Python 3.10 onwards.)

===Frame Size and Geometry===

{{Code|code=
# set up a variable to hold the Main Window to save some typing...
mainWin = FreeCAD.Gui.getMainWindow()

mainWin.showFullScreen() # no menu bars, every last pixel is given over to FreeCAD
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.showMaximized() # show maximised within the screen, window edges and the menu bar will be displayed
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.showNormal() # show at the last non-maximised or non-minimised size (and location)
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.setGeometry(50, 50, 800, 800) # specifically set FreeCAD main window's size and location, this will become the new setting for 'showNormal()'

mainWin.showMinimized() # FreeCAD will disappear from view after this command...
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()
}}

These same commands can be executed on a user generated window, the syntax does not change.


{{Powerdocnavi{{#translation:}}}}
[[Category:Developer Documentation{{#translation:}}]]
[[Category:Python Code{{#translation:}}]]