<languages/>
<translate>

<!--T:1-->
{{Macro
|Icon=Macro_server.svg
|Name=Macro Server
|Description=Allows external control over FreeCAD for automation purposes
|Author=Jjustra
|Download=[[Media:Macro_server.svg]]
|Date=2026-01-30
|Version=1.0
|FCVersion=all
}}

== Description == <!--T:2-->

<!--T:3-->
Useful tool for FreeCAD automatization. The aim is for a small, versatile, 'top level'-only program.

<!--T:4-->
Remote FreeCAD management, no actual model editing (for such goal, see Extensions).

<!--T:5-->
You need client to send commands to this server. Included is simple python command line utility as reference implementation.

<!--T:6-->
This allows you to globally (but still in server's space not FreeCAD itself) select :

<!--T:7-->
* document
* object
* spreadsheet
* path (mainly for export)

<!--T:8-->
Subsequent operations may require document/object/spreadsheet/path

<!--T:9-->
(most of those arguments are optional)

<!--T:10-->
* given value is used first
* then global one
* and lastly active/default selection in FreeCAD itself

<!--T:11-->
e.g.:

<!--T:12-->
* you can get list of objects in active document with command 'O'
* you can also get list of objects in concrete document with command 'Oconcrete_document'

<!--T:13-->
  (list of all documents is returned by command 'D')

<!--T:14-->
It also allows you to get list of :

<!--T:15-->
* opened documents
* objects with their Name and Label
* cells in spreadsheet with their values

<!--T:16-->
And you can even :

<!--T:17-->
* get cell value
* set cell value
* recompute (needed after setting cells)
* export

== Usage == <!--T:18-->

=== Server === <!--T:19-->

<!--T:20-->
You start server by running macro. You can stop it the same way. Macro, therefore, acts as mere switch button and real magic happens elsewhere.

=== Client === <!--T:21-->

<!--T:22-->
Included client script accepts command(s) in form of command line arguments. Each argument is one command.

<!--T:23-->
e.g.: ./freecad-ctl.py 'dMy_document_1' C '!B1 123' C

<!--T:24-->
This selects '''My_document_1''', returns all cell's values in default spreadsheet, sets cell B1 to 123 and return all values again.

=== Note === <!--T:25-->

<!--T:26-->
Don't forget to set ROOT path to server's stdin/stdout files - both in client AND in server before running it (variable ROOT at start of both source codes). Stdin/stdout files will be created automaticaly.

=== Communication protocol === <!--T:27-->

<!--T:28-->
Informations are exchanged thru two files. From server's POV one is input, the other output. From client's POV server's input is its output and vice versa.

<!--T:29-->
Every command returns some response.

==== Command format ==== <!--T:30-->

</translate>
<syntaxhighlight lang="text">
<one-letter-mod><name> <data string>
</syntaxhighlight>
<translate>

<!--T:32-->
e.g.:

</translate>
<syntaxhighlight lang="text">
!B1 123
</syntaxhighlight>
<translate>

<!--T:34-->
where :

<!--T:35-->
* '''!''' is mod/command
* '''B1''' is name
* '''123''' is string value (can be another name or just value; depends on situation)

<!--T:36-->
this sets cell B1 (in global or active document and spreadsheet) to value 123

==== Commands ==== <!--T:37-->

<!--T:38-->
''I'' - get server id

<!--T:39-->
''D'' - get list of open documents in form : d<document>

<!--T:40-->
''O[<document>]'' - get list of objects in form : o<object> <label>

<!--T:41-->
''C[<document>] [<spreadsheet>]'' - get list of cells in form : c<cell-id> <value>

<!--T:42-->
''d<document>'' - select document

<!--T:43-->
''s[<document>] <spreadsheet>'' - select spreadsheet

<!--T:44-->
''o[<document>] <object-name>'' - select object

<!--T:45-->
''p <file-path>'' - select/set path

<!--T:46-->
''@<cell-id> [<spreadsheet>]'' - get cell value in form : c<cell-id> <value>

<!--T:47-->
''!<cell-id> <value>'' - set cell value

<!--T:48-->
''r[<document>]'' - recompute document

<!--T:49-->
''e[<nowiki><object>] [<file-path>]</nowiki>'' - export selected object

==== Examples ==== <!--T:50-->

<!--T:51-->
Select document '''My_document_0'''

</translate>
<syntaxhighlight lang="text">
dMy_document_0
</syntaxhighlight>
<translate>

<!--T:53-->
Get list of objects from '''My_document_1'''

</translate>
<syntaxhighlight lang="text">
OMy_document_1
</syntaxhighlight>
<translate>

<!--T:55-->
Get list of objects from '''My_document_0'''

</translate>
<syntaxhighlight lang="text">
O
</syntaxhighlight>
<translate>

<!--T:57-->
Unselect document

</translate>
<syntaxhighlight lang="text">
d
</syntaxhighlight>
<translate>

<!--T:59-->
Get list of objects from FreeCAD's active document

</translate>
<syntaxhighlight lang="text">
O
</syntaxhighlight>
<translate>

<!--T:61-->
Get list of cells from default spreadsheet in '''My_document_0'''

</translate>
<syntaxhighlight lang="text">
CMy_document_0
</syntaxhighlight>
<translate>

<!--T:63-->
Get list of cells from '''My_spreadsheet''' in '''My_document_0'''

</translate>
<syntaxhighlight lang="text">
CMy_document_0 My_spreadsheet
</syntaxhighlight>
<translate>

<!--T:65-->
Set path

</translate>
<syntaxhighlight lang="python3">
p /tmp/exported-part.stl
</syntaxhighlight>
<translate>

<!--T:67-->
Export '''Object_0''' to selected path

</translate>
<syntaxhighlight lang="python3">
eObject_0
</syntaxhighlight>
<translate>

== Extensions == <!--T:69-->

<!--T:70-->
In case more functionality is required, beyond scope of this server, additions can be easily made.

<!--T:71-->
Every command must return some response.

== Script == <!--T:72-->

=== server macro === <!--T:73-->

<!--T:74-->
server.FCMacro

<!--T:75-->
{{MacroCode|code=
## created on ##
# OS: Windows 10 build 19045
# Architecture: x86_64
# Version: 1.0.2.39319 (Git) Conda
# Build type: Release
# Branch: (HEAD detached at 1.0.2)
# Hash: 256fc7eff3379911ab5daf88e10182c509aa8052
# Python 3.11.13, Qt 5.15.15, Coin 4.0.3, Vtk 9.3.0, OCC 7.8.1
# Locale: Czech/Czech Republic (cs_CZ)
# Stylesheet/Theme/QtStyle: FreeCAD Dark.qss/FreeCAD Dark/Fusion
# Installed mods: 
#   * freecad.gears 1.3.0
#   * sheetmetal 0.7.58

<!--T:76-->
__Title__="server"
__Author__ = "Jjustra"
__Version__ = "1.0"
__Date__    = "2026-01-30"
__Comment__ = "This is the comment of the macro"
__Web__ = "https://forum.freecad.org"
__Wiki__ = "https://wiki.freecad.org/index.php?title=Macro_server"
__Icon__  = "/usr/lib/freecad/Mod/plugins/icons/server"
__IconW__  = "C:/Users/YourUserName/AppData/Roaming/FreeCAD"
__Help__ = "start the macro and run client"
__Status__ = "stable"
__Requires__ = "freecad all"
__Communication__ = "https://wiki.freecad.org/index.php?title=User:Jjustra"


<!--T:77-->
import FreeCAD

<!--T:78-->
# Location of the input/output files
ROOT = 'c:/tmp'


<!--T:79-->
if 'server' not in dir(FreeCAD):
	# Server not running - we will start it then
	
	import os
	from threading import Event,Thread
	import Mesh
	import time

<!--T:80-->
## --- brcko lib start --- ##
	import sys,os

	<!--T:81-->
stdin = []
	stdinpos = []
	stdout = []

	<!--T:82-->
def addstdin(path):
		global stdin,stdinpos
		if os.path.exists(path):
			pos = os.path.getsize(path)
		else:
			pos = 0
		stdin.append(path)
		stdinpos.append(pos)

	<!--T:83-->
def addstdout(path):
		global stdout
		stdout.append(path)


	<!--T:84-->
def getstdin():
		global stdin,stdinpos

		<!--T:85-->
data = []
		for i,path in enumerate(stdin):

			<!--T:86-->
if not os.path.exists(path): continue

			<!--T:87-->
f = open(path)
			f.seek(stdinpos[i])
			_data = f.read()
			f.close()

			<!--T:88-->
# Line-buffered
			_i = _data.rfind('\n') + 1
			_data = _data[:_i]

			<!--T:89-->
data.append(_data)
			stdinpos[i] += _i

		<!--T:90-->
return data

	<!--T:91-->
def putstdout(data,i=0):
		global stdout

		<!--T:92-->
if i >= len(stdout): return
		path = stdout[i]

		<!--T:93-->
if path == '-':
			sys.stdout.write(data)
		else:
			f = open(path,'a', encoding="utf-8", newline='\n')
			f.write(data)
			f.close()

<!--T:94-->
## --- brcko lib end --- ##


	<!--T:95-->
_cb_d = {}
	id = 0
	path = ''
	_id = 0
	_doc = 0
	_ss = 0
	_obj = 0
	_path = 0


<!--T:96-->
## --- utils start --- ##

	<!--T:97-->
def getDoc(n=0):
		'''Get document'''
		global _doc
		
		if n:
			try:
				doc = App.getDocument(n)
			except NameError:
				return 0
		elif _doc:
			doc = _doc
		else:
			doc = App.ActiveDocument

		<!--T:98-->
return doc

	<!--T:99-->
def getSS(s=0,n=0):
		'''Get spreadsheet'''
		global _ss

		<!--T:100-->
doc = getDoc(n)
		if not doc: return 0

		<!--T:101-->
if s:
			ss = doc.getObject(s)
		elif _ss:
			ss = _ss
		else:
			ss = doc.getObject('Spreadsheet')

		<!--T:102-->
return ss

	<!--T:103-->
def getObj(s=0,n=0):
		'''Get object'''
		global _obj

		<!--T:104-->
doc = getDoc(n)
		if not doc: return 0

		<!--T:105-->
if s:
			obj = doc.getObject(s)
		elif _obj:
			obj = _obj
		else:
			obj = doc.ActiveObject

		<!--T:106-->
return obj

	<!--T:107-->
def getPath(s=0, default_fn=0):
		'''Get file path (for export mainly)'''
		global _path,ROOT

		<!--T:108-->
path = ''

		<!--T:109-->
if not default_fn:
			default_fn='file'

		<!--T:110-->
if s:
			path = s
		elif _path:
			path = _path
		else:
			path = ROOT

		<!--T:111-->
path = path.replace('\\','/')# make it objectively right ;)
		
		if os.path.isdir(path):
			path = path + '/' + default_fn
		if '.' not in path.split('/')[-1]:
			path += '.stl'

		<!--T:112-->
return path

	<!--T:113-->
def dlgln(ln):
		m = ''
		n = ''
		s = ''

		<!--T:114-->
m = ln[0]
		ln = ln[1:]

		<!--T:115-->
if ln:

			<!--T:116-->
if ln[0] == ' ':
				s = ln[1:]
			else:
				if ' ' in ln:
					n,s = ln.split(' ',1)
				else:
					n = ln
		
		return m,n,s

	<!--T:117-->
def register(m, fc):
		'''Register command function with respective m-code'''
		global _cb_d
		_cb_d[m] = fc

<!--T:118-->
## --- utils end --- ##


<!--T:119-->
## --- thread function start --- ##

	<!--T:120-->
def _th(qe,id):
		global _cb_d,_id
		
		while not qe.is_set():
			for data in getstdin():
				for ln in data.split('\n'):
					if not ln: continue
					print('#D : server : got input :',ln)
					m,n,s = dlgln(ln)
					if m in _cb_d:
						if not _id or _id == id or _cb_d[m] == fc_selectId:
							# Only process commands if :
							#  id is empty
							#  id equals this instance's id
							#  we are about to execute selectId command
							_cb_d[m](m,n,s)
					else:
						print('#E : server : unknown command :',m)
			time.sleep(1)

<!--T:121-->
## --- thread function end --- ##


<!--T:122-->
## --- stdlib start --- ##
	
	def fc_getId(m,n,s):
		resp = 'i%s\n' % FreeCAD.server[0]
		#resp += '#I : server : fc_getId : done\n'
		putstdout(resp)
	
	def fc_docList(m,n,s):
		resp = ''
		
		for k,_ in App.listDocuments().items():
			resp += 'd%s\n' % k
		
		if not resp:
			resp += '#I : server : fc_docList : empty\n'
		
		putstdout(resp)

	<!--T:123-->
def fc_objList(m,n,s):
		resp = ''
		doc = getDoc(n)
		
		if not doc:
			resp += '#E : server : fc_objList : no doc\n'
		else:
		
			for obj in doc.Objects:
				resp += 'o%s %s\n' % (obj.Name, obj.Label)
			
			if not resp:
				resp += '#I : server : fc_objList : empty\n'
		
		putstdout(resp)

	<!--T:124-->
def fc_cellsList(m,n,s):
		resp = ''
		ss = getSS(s,n)

		<!--T:125-->
if not ss:
			resp += '#E : server : fc_cellsList : no sheet\n'
		else:

			<!--T:126-->
# Build list of non-empty cells
			for k in ss.getNonEmptyCells():
				v = ss.get(k)
				resp += 'c%s %s\n' % (k,v)
			
			if not resp:
				resp += '#I : server : fc_cellsList : empty\n'
		
		# Sends it
		putstdout(resp)
	

	<!--T:127-->
def fc_selectId(m,n,s):
		global _id
		
		_id = n
		
		putstdout('#I : server : fc_selectId : done\n')
		
	def fc_selectDoc(m,n,s):
		global _doc
		
		resp = ''

		<!--T:128-->
if n:
			try:
				_doc = App.getDocument(n)
			except NameError:
				resp = '#E : server : fc_selectDoc : no doc\n'
		else:
			_doc = 0
		
		if not resp:
			resp = '#I : server : fc_selectDoc : done\n'

		<!--T:129-->
putstdout(resp)
	
	def fc_selectSpreadsheet(m,n,s):
		global _ss

		<!--T:130-->
resp = ''
		doc = getDoc(n)

		<!--T:131-->
if not doc:
			resp += '#E : server : fc_selectSpreadsheet : no doc\n'
		else:
		
			if s:
				_ss = doc.getObject(s)
			else:
				_ss = 0
			
			resp = '#I : server : fc_selectSpreadsheet : done\n'

		<!--T:132-->
putstdout(resp)
	
	def fc_selectObj(m,n,s):
		global _obj

		<!--T:133-->
resp = ''
		doc = getDoc(n)

		<!--T:134-->
if not doc:
			resp += '#E : server : fc_selectObj : no doc\n'
		else:

			<!--T:135-->
if s:
				_obj = doc.getObject(s)
			else:
				_obj = 0
			
			if not resp:
				resp = '#I : server : fc_selectObj : done\n'
	
		putstdout(resp)

	<!--T:136-->
def fc_selectPath(m,n,s):
		global _path

		<!--T:137-->
if s:
			_path = s
		else:
			_path = 0
	
		putstdout('#I : server : fc_selectPath : done\n')

	
	<!--T:138-->
def fc_getCell(m,n,s):
		resp = ''
		ss = getSS(s)
		if not ss:
			resp = '#E : server : fc_getCell : no sheet\n'
		else:
		
			try:
				v = ss.get(n)
				resp = 'c%s %d\n' % (n, v)
			except ValueError:
				resp = '#E : server : fc_getCell : no cell\n'
				
		#resp += '#I : server : fc_getCell : done\n'
		putstdout(resp)
	
	def fc_setCell(m,n,s):
		resp = ''
		ss = getSS()
		if not ss:
			resp = '#E : server : fc_setCell : no sheet\n'
		else:
			v = ss.set(n,s)
			resp = '#I : server : fc_setCell : done\n'
	
		putstdout(resp)

	
	<!--T:139-->
def fc_recompute(m,n,s):
		getDoc(n).recompute()
		
		putstdout('#I : server : fc_recompute : done\n')

	<!--T:140-->
def fc_export(m,n,s):
		resp = ''
		obj = getObj(n)
		path = getPath(s, obj.Label)

		<!--T:141-->
if not obj:
			resp = '#E : server : fc_export : no object\n'
		else:
			
			if not path:
				resp = '#E : server : fc_export : no path\n'
			else:
			
				if hasattr(Mesh, "exportOptions"):
					options = Mesh.exportOptions(path)
					Mesh.export([obj], path, options)
				else:
					Mesh.export([obj], path)
				
				resp += '#I : server : fc_export : done : %s\n' % path

		<!--T:142-->
putstdout(resp)


	<!--T:143-->
def fc_(m,n,s):
		resp = ''
		putstdout(resp)

	<!--T:144-->
def fc_(m,n,s):
		resp = ''
		putstdout(resp)

	<!--T:145-->
def fc_(m,n,s):
		resp = ''
		putstdout(resp)

<!--T:146-->
## --- stdlib end --- ##


<!--T:147-->
## --- Extensions start --- ##
## --- Extensions end --- ##


	<!--T:148-->
# Register all command functions with their codes
	
	register('I', fc_getId)
	register('D', fc_docList)
	register('O', fc_objList)
	register('C', fc_cellsList)

	<!--T:149-->
register('i', fc_selectId)
	register('d', fc_selectDoc)
	register('s', fc_selectSpreadsheet)
	register('o', fc_selectObj)
	register('p', fc_selectPath)
	
	register('@', fc_getCell)
	register('!', fc_setCell)
	
	register('r', fc_recompute)
	register('e', fc_export)
	
	#register('', fc_)


<!--T:150-->
## --- Extensions registration start --- ##

	<!--T:151-->
#register('', fc_)

<!--T:152-->
## --- Extensions registration end --- ##


	<!--T:153-->
# Setup brcko lib
	path = os.path.abspath(ROOT)
	# in <-> in
	# out <-> out
	addstdin('%s/server.stdin' %path)
	addstdout('%s/server.stdout' %path)


	<!--T:154-->
# Little bit of flexing O:)
	genid = lambda seed,lvl: 'QWERTYUIOPASDFGHJKLZXCVBNM'[seed%26]+genid((seed*12345)%56789,lvl-1) if lvl>0 else ''
	id = genid(int(time.time()*1000),8)
	
	qe = Event()
	th = Thread(target=_th,args=(qe,id))

	<!--T:155-->
FreeCAD.server = (id,qe,th)
	th.start()

	<!--T:156-->
print('#I : server : started :',id)

<!--T:157-->
else:
	# Server is running - let's stop it now
	
	(id,qe,th) = FreeCAD.server

	<!--T:158-->
qe.set()
	del(FreeCAD.server)

	<!--T:159-->
print('#I : server : stopped')
}}

=== client script === <!--T:160-->

<!--T:161-->
freecad-ctl.py

<!--T:162-->
<syntaxhighlight lang="python3" line="1">
#!/usr/bin/python3

<!--T:163-->
import os
import time


<!--T:164-->
# Location of the input/output files
ROOT = 'c:/tmp'


<!--T:165-->
## --- brcko lib start --- ##
import sys,os

<!--T:166-->
stdin = []
stdinpos = []
stdout = []

<!--T:167-->
def addstdin(path):
	global stdin,stdinpos
	if os.path.exists(path):
		pos = os.path.getsize(path)
	else:
		pos = 0
	stdin.append(path)
	stdinpos.append(pos)

<!--T:168-->
def addstdout(path):
	global stdout
	stdout.append(path)


<!--T:169-->
def getstdin():
	global stdin,stdinpos

	<!--T:170-->
data = []
	for i,path in enumerate(stdin):

		<!--T:171-->
if not os.path.exists(path): continue

		<!--T:172-->
f = open(path)
		f.seek(stdinpos[i])
		_data = f.read()
		f.close()

		<!--T:173-->
# Line-buffered
		_i = _data.rfind('\n') + 1
		_data = _data[:_i]

		<!--T:174-->
data.append(_data)
		stdinpos[i] += _i

	<!--T:175-->
return data

<!--T:176-->
def putstdout(data,i=0):
	global stdout

	<!--T:177-->
if i >= len(stdout): return
	path = stdout[i]

	<!--T:178-->
if path == '-':
		sys.stdout.write(data)
	else:
		f = open(path,'a', encoding="utf-8", newline='\n')
		f.write(data)
		f.close()

<!--T:179-->
## --- brcko lib end --- ##


<!--T:180-->
# Process command line arguments

<!--T:181-->
cmd = ''

<!--T:182-->
if len(sys.argv) > 1:
	# Use command line arguments to build command script
	
	for a in sys.argv[1:]:
		if a == '-':
			# Read list of commands from (real) stdin
			cmd + sys.stdin.read().replace('\r','\n')
		else:
			cmd += a
		cmd += '\n'
#else:
	# Default : get document list

<!--T:183-->
#	cmd = 'D\n'


<!--T:184-->
# Setup brcko lib
path = os.path.abspath(ROOT)
# in <-> out
# out <-> in
addstdin('%s/server.stdout' %path)
addstdout('%s/server.stdin' %path)


<!--T:185-->
# Send command script
if cmd:
	putstdout(cmd)

<!--T:186-->
try:

	<!--T:187-->
# Wait for response (indicated by file size change / file creation)
	if not os.path.exists(stdin[0]):
		while not os.path.exists(stdin[0]):
			time.sleep(.1)
	else:
		sz = os.path.getsize(stdin[0])
		while sz == os.path.getsize(stdin[0]):
			time.sleep(.1)

	<!--T:188-->
# Just to be sure write ended
	time.sleep(.5)

<!--T:189-->
except KeyboardInterrupt:
	sys.exit()

<!--T:190-->
# Print response
for data in getstdin():
	print(data)
</syntaxhighlight>


</translate>