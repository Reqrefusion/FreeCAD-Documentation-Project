<languages/>

{{TOCright}}

<span id="Introduction"></span>
==Введение==

На этой странице мы покажем, как с помощью Python можно легко создать дополнительную функциональность. В этом упражнении мы создадим новый инструмент, который будет рисовать линию. Затем этот инструмент можно связать с командой FreeCAD, и эта команда может быть вызвана любым элементом интерфейса, например, пунктом меню или кнопкой на панели инструментов.

<span id="The_main_script"></span>
==Основной скрипт==

Сначала мы напишем скрипт, содержащий всю нашу функциональность. Затем мы сохраним его в файл и импортируем в FreeCAD, чтобы сделать доступными все его классы и функции. Запусти твой любимый редактор кода и введи следующие строки:

{{Code|code=
import FreeCADGui, Part
from pivy.coin import *

class line:

    """This class will create a line after the user clicked 2 points on the screen"""

    def __init__(self):
        self.view = FreeCADGui.ActiveDocument.ActiveView
        self.stack = []
        self.callback = self.view.addEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.getpoint)

    def getpoint(self, event_cb):
        event = event_cb.getEvent()
        if event.getState() == SoMouseButtonEvent.DOWN:
            pos = event.getPosition()
            point = self.view.getPoint(pos[0], pos[1])
            self.stack.append(point)
            if len(self.stack) == 2:
                l = Part.LineSegment(self.stack[0], self.stack[1])
                shape = l.toShape()
                Part.show(shape)
                self.view.removeEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.callback)
}}
{{Top}}
<span id="Detailed_explanation"></span>
== Подробное объяснение ==

{{Code|code=
import Part, FreeCADGui
from pivy.coin import *
}}

В Python, когда ты хочешь использовать функции из другого модуля, сначала нужно импортировать его. В нашем случае нам понадобятся функции из модуля [[Part_Workbench/ru|Деталь (Part)]] для создания линии и из модуля Gui {{incode|FreeCADGui}} для доступа к [[3D_view/ru|3D виду]]. Нам также необходимо полное содержимое библиотеки Coin, чтобы мы могли напрямую использовать все объекты Coin, такие как {{incode|SoMouseButtonEvent}} и т.д.

{{Code|code=
class line:
}}

Здесь мы определяем наш основной класс. Почему мы используем класс, а не функцию? Причина в том, что нам нужно, чтобы наш инструмент оставался "живым", пока мы ждём, когда пользователь нажмёт на экран. Функция завершается, когда её задача выполнена, а объект (класс определяет объект) остаётся живым, пока его не уничтожат

{{Code|code=
"""This class will create a line after the user clicked 2 points on the screen"""
}}

В Python каждый класс или функция могут иметь строку документации (docstring). Это особенно полезно в FreeCAD, так как при вызове класса в интерпретаторе строка описания будет отображаться в виде всплывающей подсказки.

{{Code|code=
def __init__(self):
}}

Классы Python всегда могут содержать функцию {{incode|__init__}}, которая выполняется при вызове класса для создания объекта. Сюда мы поместим всё, что должно произойти при запуске нашего инструмента для создания линии.

{{Code|code=
self.view = FreeCADGui.ActiveDocument.ActiveView
}}

В классе обычно требуется добавлять к именам переменных {{incode|self.}}, чтобы переменные были легко доступны для всех функций внутри и вне класса. Здесь мы будем использовать {{incode|self.view}} для доступа и манипуляций с активным 3D-видом.

{{Code|code=
self.stack = []
}}

Здесь мы создаём пустой список, который будет содержать 3D-точки, присланные функцией {{incode|getpoint()}}.

{{Code|code=
self.callback = self.view.addEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.getpoint)
}}

Это очень важная часть. Поскольку мы имеем дело со сценой [https://github.com/coin3d/coin/wiki Coin3D], мы используем механизм обратного вызова Coin, который позволяет вызывать функцию каждый раз, когда происходит определённое событие сцены. В нашем случае мы создаём обратный вызов для событий [https://coin3d.github.io/Coin/html/classSoMouseButtonEvent.html SoMouseButtonEvent] и привязываем его к функции {{incode|getpoint()}}. Теперь каждый раз, когда кнопка мыши будет нажата или отпущена, будет выполняться функция {{incode|getpoint()}}.

Обратите внимание, что существует также альтернатива {{incode|addEventCallbackPivy()}} под названием {{incode|addEventCallback()}}, которая не зависит от pivy. Но поскольку pivy - это очень эффективный и естественный способ доступа к любой части сцены Coin, он является лучшим выбором.
{{Top}}
{{Code|code=
def getpoint(self, event_cb):
}}

Теперь мы определим функцию {{incode|getpoint()}}, которая будет выполняться при нажатии кнопки мыши в 3D-виде. Эта функция будет получать аргумент, который мы назовём {{incode|event_cb}}. Из этого обратного вызова мы можем получить доступ к объекту события, который содержит несколько частей информации (подробнее [[Code_snippets/ru#Observe_mouse_events_in_the_3D_viewer_via_Python|здесь]]).

{{Code|code=
if event.getState() == SoMouseButtonEvent.DOWN:
}}

Функция {{incode|getpoint()}} будет вызываться при нажатии или отпускании кнопки мыши. Но мы хотим выбрать 3D-точку только при нажатии кнопки, иначе мы получим две 3D-точки, расположенные очень близко друг к другу. Поэтому мы должны здесь это проверить.

{{Code|code=
pos = event.getPosition()
}}

Здесь мы получаем экранные координаты курсора мыши.

{{Code|code=
point = self.view.getPoint(pos[0], pos[1])
}}

Эта функция выдаёт нам вектор FreeCAD (x,y,z), содержащий 3D-точку, которая лежит в фокальной плоскости, прямо под курсором мыши. Если вы находитесь в режиме просмотра камеры, представьте себе луч, исходящий из камеры, проходящий через курсор мыши и попадающий в фокальную плоскость. Это и есть местоположение нашей 3D-точки. Если мы находимся в ортогональном режиме, то луч параллелен направлению обзора.

{{Code|code=
self.stack.append(point)
}}

Мы добавляем нашу новую точку в стек (stack).

{{Code|code=
if len(self.stack) == 2:
}}

Достаточно ли у нас уже точек? Если да, то давай рисовать линию!

{{Code|code=
l = Part.LineSegment(self.stack[0], self.stack[1])
}}

Здесь мы используем функцию {{incode|LineSegment()}} из модуля Деталь (Part), которая создаёт линию из двух векторов FreeCAD. Линия не привязана ни к одному объекту в нашем активном документе, поэтому на экране ничего не появляется.

{{Code|code=
shape = l.toShape()
}}

Документ FreeCAD может принимать только геометрические фигуры из модуля Деталь (Part). Фигуры (Shapes) - это наиболее общий тип в модуле Деталь (Part). Поэтому мы должны преобразовать нашу линию в фигуру, прежде чем добавлять её в документ.

{{Code|code=
Part.show(shape)
}}

В модуле Деталь (Part) есть очень удобная функция {{incode|show()}}, которая создаёт новый объект в документе и привязывает к нему фигуру. Мы также могли бы сначала создать новый объект в документе, а затем привязать к нему фигуру вручную.

{{Code|code=
self.view.removeEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.callback)
}}

Поскольку мы закончили работу с нашей линией, мы удалим здесь механизм обратного вызова.
{{Top}}
<span id="Testing_the_script"></span>
== Тестирвание скрипта ==

<div class="mw-translate-fuzzy">
Теперь, давайте сохраним наш сценарий где нибудь где FreeCAD python интепритатор сможет его найти. Когда импортируются модули, интепритатор просматривает следующие места: директорию куда установлен python,FreeCAD bin директорию, и все папки FreeCAD модулей. Так что, лучшим решением будет создать новую папку в одной из FreeCAD [[Installing_more_workbenches|Mod папках]], и сохранит наш сценарий в ней. Например, давайте создадим папку "MyScripts" , и сохраним наш сценарий как "exercise.py".
</div>

<div class="mw-translate-fuzzy">
Теперь, когда все готово, давайте запустим FreeCAD, создадим новый документ, и введем в python интерпритатор:
</div>

{{Code|code=
import exercise
}}

<div class="mw-translate-fuzzy">
Если сообщений об ошибке не появится, это означает, что наш учебный сценарий был загружен. Теперь мы можем проверить его содержимое:
</div>

{{Code|code=
dir(exercise)
}}

<div class="mw-translate-fuzzy">
Команда dir() встроенная python которая выдает список содержащегося в модуле. Мы можем видеть здесь нас ждет, наш класс line(). Теперь давайте протестируем его:
</div>

{{Code|code=
'line' in dir(exercise)
}}

Приступим к тестированию:

{{Code|code=
exercise.line()
}}

<div class="mw-translate-fuzzy">
Затем, щелкнем два раза на 3D виде, и бинго, вот наша линия! Чтобы сделать это снова , просто опять введите exercise.line(), и ещё раз, и ещё раз... Чувствуете себе прекрасно, не так ли?
</div>
{{Top}}
<span id="Registering_the_script"></span>
==Регистрация сценария==

<div class="mw-translate-fuzzy">
Теперь, для нашего нового инструмента "линия" будет здорово, если он будет обладать кнопкой в интерфейсе, так чтобы нам не нужно было его каждый раз вводить. Простейший путь это преобразовать наш новый каталог MyScripts в полноценнный FreeCAD инструментарий(workbench). Это просто, все что нужно это поместить в файл зовущийся '''InitGui.py''' внутрь вашей MyScripts папки. InitGui.py будет содержать инструкции создания нового инструментария, м добавлять наш новый инструмент в него. Кроме того мы должны трансформировать код нашего примера, так чтобы инструмент line() был признан как официальная FreeCAD команда. Начнем с создания InitGui.py файла, и запишем в него следующий код:
</div>

{{Code|code=
class MyWorkbench (Workbench):

    MenuText = "MyScripts"

    def Initialize(self):
        import exercise
        commandslist = ["line"]
        self.appendToolbar("My Scripts", commandslist)

Gui.addWorkbench(MyWorkbench())
}}

<div class="mw-translate-fuzzy">
К  этому моменту , я думаю, вы должны понимать сценарий выше: Мы создали новый класс назвали его MyWorkbench, мы задаем заглавие(MenuText), и задаем Initialize() функцию, которая будет выполняться когда инструментарий будт загружен в FreeCAD. В этой функции, мы загружаем вск что содержится в нашем exercise файле, и добавляем в FreeCAD команды найденные внутри списка команд(commandlist). Затем, мы создаем панель инструментов названую "My Scripts" и сопоставляем наш список команд с ней. Конечно, сейчас у нас есть только один инструмент, так как наш список команд содержит один элемент. Затем, когда наш инструментарий готов, мы добавляем его в основной(главный) интерфейс.
</div>

<div class="mw-translate-fuzzy">
Но это пока не будет работать, потому что FreeCAD команда для работы должна быть отформатирована определенным образом. Так что нам нужно преобразовать(доработать) наш line() инструмент.  Наш новый exercise.py сценарий будет выглядеть следующим образом:
</div>

{{Code|code=
import FreeCADGui, Part
from pivy.coin import *

class line:

    """This class will create a line after the user clicked 2 points on the screen"""

    def Activated(self):
        self.view = FreeCADGui.ActiveDocument.ActiveView
        self.stack = []
        self.callback = self.view.addEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.getpoint)

    def getpoint(self, event_cb):
        event = event_cb.getEvent()
        if event.getState() == SoMouseButtonEvent.DOWN:
            pos = event.getPosition()
            point = self.view.getPoint(pos[0], pos[1])
            self.stack.append(point)
            if len(self.stack) == 2:
                l = Part.LineSegment(self.stack[0], self.stack[1])
                shape = l.toShape()
                Part.show(shape)
                self.view.removeEventCallbackPivy(SoMouseButtonEvent.getClassTypeId(), self.callback)

    def GetResources(self):
        return {'Pixmap': 'path_to_an_icon/line_icon.png', 'MenuText': 'Line', 'ToolTip': 'Creates a line by clicking 2 points on the screen'}

FreeCADGui.addCommand('line', line())
}}

<div class="mw-translate-fuzzy">
То, что мы сделали здесь является преобразованием нашей __init__() функции в Activated() функцию, потому что, когда FreeCAD команды выполняются, они автоматически выполняют Activated() функцию. Мы также добавили функцию GetResources(), которая сообщает FreeCAD, где он может найти значок инструмента, и каким будет название и подсказка нашего инструмента. Любой JPG, PNG или SVG изображения будут работать, как иконка, они могут быть любого размера, но лучше использовать размер, близкий к последним аспектам, как 16x16, 24x24 или 32x32.
Затем, мы добавили line() класс в качестве официального команды FreeCAD с AddCommand() методом.
</div>

<div class="mw-translate-fuzzy">
Это всё, теперь вам нужно перезапустить FreeCAD и вы получите новый хороший инструментарий с нашим новым инструментом линии!
</div>
{{Top}}
<span id="So_you_want_more?"></span>
==Вы хотите большего?==

<div class="mw-translate-fuzzy">
Если вам понравился этот пример, почему не попытаться улучшить этот маленький инструмент? Существует множесво вещей которые нужно сделать, как например:
* Добавить обратную связь с пользователем: до сих пор мы делали очень голый инструмент, пользователь может потерятся при его использовании. Таким образом мы могли бы  добавить обратную связь, сообщающую ему что делать дальше. Например, мы можем выводит сообщения в FreeCAD консоль. Загляните в FreeCAD.Console модуль
* Добавить возможность вводить координаты 3D точек вручную. Посмотрите, на пример, python input() функцию
* Добавить способность добавлять более двух точек
* Добавить события для других вещей: сейчас мы только проверяем события кнопок мыши, что если мы хотели бы также сделать что-то когда мышь перемещается, например отображать текущие координаты?
* Давать имя созданному объекту
Не стесняйтесь писать ваши вопросы или идеи на [http://forum.freecadweb.org/ forum]!
</div>

<div lang="en" dir="ltr" class="mw-content-ltr">
Don't hesitate to ask questions or share ideas on the [https://forum.freecad.org forum]!
</div>
{{Top}}
{{Powerdocnavi{{#translation:}}}}
[[Category:Developer Documentation{{#translation:}}]]
[[Category:Python Code{{#translation:}}]]
{{clear}}